{
    "cveId": "CVE-2022-49290",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mac80211 fix potential double free on mesh join While commit 6a01afcf8468 (mac80211 mesh Free ie data when leaving mesh) fixed a memory leak on mesh leave / teardown it introduced a potential memory corruption caused by a double free when rejoining the mesh ieee80211_leave_mesh() -> kfree(sdata->u.mesh.ie) ... ieee80211_join_mesh() -> copy_mesh_setup() -> old_ie = ifmsh->ie -> kfree(old_ie) This double free / kernel panics can be reproduced by using wpa_supplicant with an encrypted mesh (if set up without encryption via iw then ifmsh->ie is always NULL, which avoids this issue). And then calling $ iw dev mesh0 mesh leave $ iw dev mesh0 mesh join my-mesh Note that typically these commands are not used / working when using wpa_supplicant. And it seems that wpa_supplicant or wpa_cli are going through a NETDEV_DOWN/NETDEV_UP cycle between a mesh leave and mesh join where the NETDEV_UP resets the mesh.ie to NULL via a memcpy of default_mesh_setup in cfg80211_netdev_notifier_call, which then avoids the memory corruption, too. The issue was first observed in an application which was not using wpa_supplicant but Senf instead, which implements its own calls to nl80211. Fixing the issue by removing the kfree()ing of the mesh IE in the mesh join function and leaving it solely up to the mesh leave to free the mesh IE.",
    "keyphrases": {
        "rootcause": "double free",
        "weakness": "",
        "impact": "kernel panic",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "mac80211"
    }
}
