{
    "cveId": "CVE-2022-49450",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved rxrpc Fix listen() setting the bar too high for the prealloc rings AF_RXRPCs listen() handler lets you set the backlog up to 32 (if you bump up the sysctl), but whilst the preallocation circular buffers have 32 slots in them, one of them has to be a dead slot because were using CIRC_CNT(). This means that listen(rxrpc_sock, 32) will cause an oops when the socket is closed because rxrpc_service_prealloc_one() allocated one too many calls and rxrpc_discard_prealloc() wont then be able to get rid of them because itll think the ring is empty. rxrpc_release_calls_on_socket() then tries to abort them, but oopses because call->peer isnt yet set. Fix this by setting the maximum backlog to RXRPC_BACKLOG_MAX - 1 to match the ring capacity.",
    "keyphrases": {
        "rootcause": "",
        "weakness": "",
        "impact": "oops",
        "vector": "listen(rxrpc_sock, 32)",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "rxrpc_service_prealloc_one()"
    }
}
