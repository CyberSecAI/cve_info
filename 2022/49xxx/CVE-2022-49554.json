{
    "cveId": "CVE-2022-49554",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved zsmalloc fix races between asynchronous zspage free and page migration The asynchronous zspage free worker tries to lock a zspages entire page list without defending against page migration. Since pages which havent yet been locked can concurrently migrate off the zspage page list while lock_zspage() churns away, lock_zspage() can suffer from a few different lethal races. It can lock a page which no longer belongs to the zspage and unsafely dereference page_private(), it can unsafely dereference a torn pointer to the next page (since theres a data race), and it can observe a spurious NULL pointer to the next page and thus not lock all of the zspages pages (since a single page migration will reconstruct the entire page list, and create_page_chain() unconditionally zeroes out each list pointer in the process). Fix the races by using migrate_read_lock() in lock_zspage() to synchronize with page migration.",
    "keyphrases": {
        "component": "zsmalloc",
        "rootcause": "races between asynchronous zspage free and page migration",
        "vector": "",
        "weakness": "data race",
        "product": "Linux kernel",
        "impact": "NULL pointer dereference, unsafely dereference page_private(), unsafely dereference a torn pointer, unsafely dereference a torn pointer to the next page",
        "attacker": "",
        "version": ""
    }
}
