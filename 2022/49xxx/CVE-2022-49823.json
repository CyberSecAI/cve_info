{
    "cveId": "CVE-2022-49823",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved ata libata-transport fix error handling in ata_tdev_add() In ata_tdev_add(), the return value of transport_add_device() is not checked. As a result, it causes null-ptr-deref while removing the module, because transport_remove_device() is called to remove the device that was not added. Unable to handle kernel NULL pointer dereference at virtual address 00000000000000d0 CPU 13 PID 13603 Comm rmmod Kdump loaded Tainted G W 6.1.0-rc3+ #36 pstate 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc device_del+0x48/0x3a0 lr device_del+0x44/0x3a0 Call trace device_del+0x48/0x3a0 attribute_container_class_device_del+0x28/0x40 transport_remove_classdev+0x60/0x7c attribute_container_device_trigger+0x118/0x120 transport_remove_device+0x20/0x30 ata_tdev_delete+0x24/0x50 [libata] ata_tlink_delete+0x40/0xa0 [libata] ata_tport_delete+0x2c/0x60 [libata] ata_port_detach+0x148/0x1b0 [libata] ata_pci_remove_one+0x50/0x80 [libata] ahci_remove_one+0x4c/0x8c [ahci] Fix this by checking and handling return value of transport_add_device() in ata_tdev_add(). In the error path, device_del() is called to delete the device which was added earlier in this function, and ata_tdev_free() is called to free ata_dev.",
    "keyphrases": {
        "component": "ata libata-transport",
        "rootcause": "return value of transport_add_device() is not checked",
        "vector": "",
        "weakness": "",
        "product": "Linux kernel",
        "impact": "Unable to handle kernel NULL pointer dereference, null-ptr-deref",
        "attacker": "",
        "version": "6.1.0-rc3+"
    }
}
