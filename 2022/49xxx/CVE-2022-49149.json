{
    "cveId": "CVE-2022-49149",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved rxrpc Fix call timer start racing with call destruction The rxrpc_call struct has a timer used to handle various timed events relating to a call. This timer can get started from the packet input routines that are run in softirq mode with just the RCU read lock held. Unfortunately, because only the RCU read lock is held - and neither ref or other lock is taken - the call can start getting destroyed at the same time a packet comes in addressed to that call. This causes the timer - which was already stopped - to get restarted. Later, the timer dispatch code may then oops if the timer got deallocated first. Fix this by trying to take a ref on the rxrpc_call struct and, if successful, passing that ref along to the timer. If the timer was already running, the ref is discarded. The timer completion routine can then pass the ref along to the calls work item when it queues it. If the timer or work item where already queued/running, the extra ref is discarded.",
    "keyphrases": {
        "rootcause": "",
        "weakness": "timer race condition",
        "impact": "oops",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "rxrpc_call struct"
    }
}
