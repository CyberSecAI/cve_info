{
  "cveId": "CVE-2022-49789",
  "version": "1.0.0",
  "timestamp": "2025-07-04T16:12:41.853043+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved scsi zfcp Fix double free of FSF request when qdio send fails We used to use the wrong type of integer in zfcp_fsf_req_send() to cache the FSF request ID when sending a new FSF request. This is used in case the sending fails and we need to remove the request from our internal hash table again (so we dont keep an invalid reference and use it when we free the request again). In zfcp_fsf_req_send() we used to cache the ID as int (signed and 32 bit wide), but the rest of the zfcp code (and the firmware specification) handles the ID as unsigned long/u64 (unsigned and 64 bit wide [s390x ELF ABI]). For one this has the obvious problem that when the ID grows past 32 bit (this can happen reasonably fast) it is truncated to 32 bit when storing it in the cache variable and so doesnt match the original ID anymore. The second less obvious problem is that even when the original ID has not yet grown past 32 bit, as soon as the 32nd bit is set in the original ID (0x80000000 = 2147483648) we will have a mismatch when we cast it back to unsigned long. As the cached variable is of a signed type, the compiler will choose a sign-extending instruction to load the 32 bit variable into a 64 bit register (e.g. lgf %r11,188(%r15)). So once we pass the cached variable into zfcp_reqlist_find_rm() to remove the request again all the leading zeros will be flipped to ones to extend the sign and wont match the original ID anymore (this has been observed in practice). If we cant successfully remove the request from the hash table again after zfcp_qdio_send() fails (this happens regularly when zfcp cannot notify the adapter about new work because the adapter is already gone during e.g. a ChpID toggle) we will end up with a double free. We unconditionally free the request in the calling function when zfcp_fsf_req_send() fails, but because the request is still in the hash table we end up with a stale memory reference, and once the zfcp adapter is either reset during recovery or shutdown we end up freeing the same memory twice. The resulting stack traces vary depending on the kernel and have no direct correlation to the place where the bug occurs. Here are three examples that have been seen in practice list_del corruption. next->prev should be 00000001b9d13800, but was 00000000dead4ead. (next=00000001bd131a00) ------------[ cut here ]------------ kernel BUG at lib/list_debug.c62! monitor event 0040 ilc2",
  "keyphrases": {
    "rootcause": "",
    "weakness": "double free",
    "impact": "kernel BUG",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "scsi zfcp"
  },
  "mitreTechnicalImpacts": []
}