{
    "cveId": "CVE-2022-49658",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved bpf Fix insufficient bounds propagation from adjust_scalar_min_max_vals Kuee reported a corner case where the tnum becomes constant after the call to __reg_bound_offset(), but the registers bounds are not, that is, its min bounds are still not equal to the registers max bounds. This in turn allows to leak pointers through turning a pointer register as is into an unknown scalar via adjust_ptr_min_max_vals(). Before func#0 @0 0 R1=ctx(off=0,imm=0,umax=0,var_off=(0x0 0x0)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0 0x0)) 0 (b7) r0 = 1 R0_w=scalar(imm=1,umin=1,umax=1,var_off=(0x1 0x0)) 1 (b7) r3 = 0 R3_w=scalar(imm=0,umax=0,var_off=(0x0 0x0)) 2 (87) r3 = -r3 R3_w=scalar() 3 (87) r3 = -r3 R3_w=scalar() 4 (47) r3 |= 32767 R3_w=scalar(smin=-9223372036854743041,umin=32767,var_off=(0x7fff 0xffffffffffff8000),s32_min=-2147450881) 5 (75) if r3 s>= 0x0 goto pc+1 R3_w=scalar(umin=9223372036854808575,var_off=(0x8000000000007fff 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767) 6 (95) exit from 5 to 7 R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0 0x0)) R3=scalar(umin=32767,umax=9223372036854775807,var_off=(0x7fff 0x7fffffffffff8000),s32_min=-2147450881) R10=fp(off=0,imm=0,umax=0,var_off=(0x0 0x0)) 7 (d5) if r3 s min/max bounds information flow into a reg_bounds_sync() helper and use it consistently everywhere. After the fix, bounds have been corrected to R3_w=scalar(imm=0,umax=0,var_off=(0x0 0x0)) and thus the register is regarded as a proper constant scalar of 0. After func#0 @0 0 R1=ctx(off=0,imm=0,umax=0,var_off=(0x0 0x0)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0 0x0)) 0 (b7) r0 = 1 R0_w=scalar(imm=1,umin=1,umax=1,var_off=(0x1 0x0)) 1 (b7) r3 = 0 R3_w=scalar(imm=0,umax=0,var_off=(0x0 0x0)) 2 (87) r3 = -r3 R3_w=scalar() 3 (87) r3 = -r3 R3_w=scalar() 4 (47) r3 |= 32767 R3_w=scalar(smin=-9223372036854743041,umin=32767,var_off=(0x7fff 0xffffffffffff8000),s32_min=-2147450881) 5 (75) if r3 s>= 0x0 goto pc+1 R3_w=scalar(umin=9223372036854808575,var_off=(0x8000000000007fff 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767) 6 (95) exit from 5 to 7 R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0 0x0)) R3=scalar(umin=32767,umax=9223372036854775807,var_off=(0x7fff 0x7fffffffffff8000),s32_min=-2147450881) R10=fp(off=0,imm=0,umax=0,var_off=(0x0 0x0)) 7 (d5) if r3 s<= 0x8000 goto pc+1 R3=scalar(umin=32769,umax=9223372036854775807,var_off=(0x7fff 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767) 8 (95) exit from 7 to 9 R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0 0x0)) R3=scalar(umin=32767,umax=32768,var_off=(0x7fff 0x8000)) R10=fp(off=0 ---truncated---",
    "keyphrases": {
        "rootcause": "insufficient bounds propagation",
        "weakness": "",
        "impact": "information flow",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "bpf"
    }
}
