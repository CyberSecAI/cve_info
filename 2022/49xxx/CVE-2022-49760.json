{
    "cveId": "CVE-2022-49760",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mm/hugetlb fix PTE marker handling in hugetlb_change_protection() Patch series mm/hugetlb uffd-wp fixes for hugetlb_change_protection(). Playing with virtio-mem and background snapshots (using uffd-wp) on hugetlb in QEMU, I managed to trigger a VM_BUG_ON(). Looking into the details, hugetlb_change_protection() seems to not handle uffd-wp correctly in all cases. Patch #1 fixes my test case. I dont have reproducers for patch #2, as it requires running into migration entries. I did not yet check in detail yet if !hugetlb code requires similar care. This patch (of 2) There are two problematic cases when stumbling over a PTE marker in hugetlb_change_protection() (1) We protect an uffd-wp PTE marker a second time using uffd-wp we will end up in the !huge_pte_none(pte) case and mess up the PTE marker. (2) We unprotect a uffd-wp PTE marker we will similarly end up in the !huge_pte_none(pte) case even though we cleared the PTE, because the pte variable is stale. Well mess up the PTE marker. For example, if we later stumble over such a wrongly modified PTE marker, well treat it like a present PTE that maps some garbage page. This can, for example, be triggered by mapping a memfd backed by huge pages, registering uffd-wp, uffd-wping an unmapped page and (a) uffd-wping it a second time or (b) uffd-unprotecting it or (c) unregistering uffd-wp. Then, ff we trigger fallocate(FALLOC_FL_PUNCH_HOLE) on that file range, we will run into a VM_BUG_ON [ 195.039560] page00000000ba1f2987 refcount1 mapcount0 mapping0000000000000000 index0x0 pfn0x0 [ 195.039565] flags 0x7ffffc0001000(reserved|node=0|zone=0|lastcpupid=0x1fffff) [ 195.039568] raw 0007ffffc0001000 ffffe742c0000008 ffffe742c0000008 0000000000000000 [ 195.039569] raw 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 [ 195.039569] page dumped because VM_BUG_ON_PAGE(compound && !PageHead(page)) [ 195.039573] ------------[ cut here ]------------ [ 195.039574] kernel BUG at mm/rmap.c1346! [ 195.039579] invalid opcode 0000",
    "keyphrases": {
        "component": "mm/hugetlb fix PTE marker handling in hugetlb_change_protection()",
        "rootcause": "!huge_pte_none(pte), stale pte variable",
        "vector": "",
        "weakness": "",
        "product": "Linux kernel",
        "impact": "VM_BUG_ON",
        "attacker": "",
        "version": ""
    }
}
