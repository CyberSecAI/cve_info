{
  "cveId": "CVE-2022-49075",
  "version": "1.0.0",
  "timestamp": "2025-07-04T16:12:41.853043+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved btrfs fix qgroup reserve overflow the qgroup limit We use extent_changeset->bytes_changed in qgroup_reserve_data() to record how many bytes we set for EXTENT_QGROUP_RESERVED state. Currently the bytes_changed is set as unsigned int, and it will overflow if we try to fallocate a range larger than 4GiB. The result is we reserve less bytes and eventually break the qgroup limit. Unlike regular buffered/direct write, which we use one changeset for each ordered extent, which can never be larger than 256M. For fallocate, we use one changeset for the whole range, thus it no longer respects the 256M per extent limit, and caused the problem. The following example test script reproduces the problem $ cat qgroup-overflow.sh #!/bin/bash DEV=/dev/sdj MNT=/mnt/sdj mkfs.btrfs -f $DEV mount $DEV $MNT # Set qgroup limit to 2GiB. btrfs quota enable $MNT btrfs qgroup limit 2G $MNT # Try to fallocate a 3GiB file. This should fail. echo echo Try to fallocate a 3GiB file... fallocate -l 3G $MNT/3G.file # Try to fallocate a 5GiB file. echo echo Try to fallocate a 5GiB file... fallocate -l 5G $MNT/5G.file # See we break the qgroup limit. echo sync btrfs qgroup show -r $MNT umount $MNT When running the test $ ./qgroup-overflow.sh (...) Try to fallocate a 3GiB file... fallocate fallocate failed Disk quota exceeded Try to fallocate a 5GiB file... qgroupid rfer excl max_rfer -------- ---- ---- -------- 0/5 5.00GiB 5.00GiB 2.00GiB Since we have no control of how bytes_changed is used, its better to set it to u64.",
  "keyphrases": {
    "rootcause": "",
    "weakness": "overflow",
    "impact": "reserve less bytes and eventually break the qgroup limit",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "btrfs"
  },
  "mitreTechnicalImpacts": []
}