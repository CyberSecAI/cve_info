{
    "cveId": "CVE-2022-49456",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved bonding fix missed rcu protection When removing the rcu_read_lock in bond_ethtool_get_ts_info() as discussed [1], I didnt notice it could be called via setsockopt, which doesnt hold rcu lock, as syzbot pointed stack backtrace CPU 0 PID 3599 Comm syz-executor317 Not tainted 5.18.0-rc5-syzkaller-01392-g01f4685797a5 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace __dump_stack lib/dump_stack.c88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c106 bond_option_active_slave_get_rcu include/net/bonding.h353 [inline] bond_ethtool_get_ts_info+0x32c/0x3a0 drivers/net/bonding/bond_main.c5595 __ethtool_get_ts_info+0x173/0x240 net/ethtool/common.c554 ethtool_get_phc_vclocks+0x99/0x110 net/ethtool/common.c568 sock_timestamping_bind_phc net/core/sock.c869 [inline] sock_set_timestamping+0x3a3/0x7e0 net/core/sock.c916 sock_setsockopt+0x543/0x2ec0 net/core/sock.c1221 __sys_setsockopt+0x55e/0x6a0 net/socket.c2223 __do_sys_setsockopt net/socket.c2238 [inline] __se_sys_setsockopt net/socket.c2235 [inline] __x64_sys_setsockopt+0xba/0x150 net/socket.c2235 do_syscall_x64 arch/x86/entry/common.c50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c80 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP 00330x7f8902c8eb39 Fix it by adding rcu_read_lock and take a ref on the real_dev. Since dev_hold() and dev_put() can take NULL these days, we can skip checking if real_dev exist. [1] https//lore.kernel.org/netdev/27565.1642742439@famine/",
    "keyphrases": {
        "rootcause": "fix missed rcu protection",
        "weakness": "",
        "impact": "",
        "vector": "setsockopt",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "bond_ethtool_get_ts_info()"
    }
}
