{
    "cveId": "CVE-2022-49006",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved tracing Free buffers when a used dynamic event is removed After 65536 dynamic events have been added and removed, the type field of the event then uses the first type number that is available (not currently used by other events). A type number is the identifier of the binary blobs in the tracing ring buffer (known as events) to map them to logic that can parse the binary blob. The issue is that if a dynamic event (like a kprobe event) is traced and is in the ring buffer, and then that event is removed (because it is dynamic, which means it can be created and destroyed), if another dynamic event is created that has the same number that new events logic on parsing the binary blob will be used. To show how this can be an issue, the following can crash the kernel # cd /sys/kernel/tracing # for i in `seq 65536` do echo pkprobes/foo do_sys_openat2 $arg1u32 > kprobe_events # done For every iteration of the above, the writing to the kprobe_events will remove the old event and create a new one (with the same format) and increase the type number to the next available on until the type number reaches over 65535 which is the max number for the 16 bit type. After it reaches that number, the logic to allocate a new number simply looks for the next available number. When an dynamic event is removed, that number is then available to be reused by the next dynamic event created. That is, once the above",
    "keyphrases": {
        "rootcause": "use-after-free",
        "weakness": "",
        "impact": "kernel crash",
        "vector": "writing to kprobe_events",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": ""
    }
}
