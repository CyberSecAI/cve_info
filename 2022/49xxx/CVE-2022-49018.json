{
    "cveId": "CVE-2022-49018",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mptcp fix sleep in atomic at close time Matt reported a splat at msk close time BUG sleeping function called from invalid context at net/mptcp/protocol.c2877 in_atomic() 1, irqs_disabled() 0, non_block 0, pid 155, name packetdrill preempt_count 201, expected 0 RCU nest depth 0, expected 0 4 locks held by packetdrill/155 #0 ffff888001536990 (&sb->s_type->i_mutex_key#6){+.+.}-{33}, at __sock_release (net/socket.c650) #1 ffff88800b498130 (sk_lock-AF_INET){+.+.}-{00}, at mptcp_close (net/mptcp/protocol.c2973) #2 ffff88800b49a130 (sk_lock-AF_INET/1){+.+.}-{00}, at __mptcp_close_ssk (net/mptcp/protocol.c2363) #3 ffff88800b49a0b0 (slock-AF_INET){+...}-{22}, at __lock_sock_fast (include/net/sock.h1820) Preemption disabled at 0x0 CPU 1 PID 155 Comm packetdrill Not tainted 6.1.0-rc5 #365 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Call Trace dump_stack_lvl (lib/dump_stack.c107 (discriminator 4)) __might_resched.cold (kernel/sched/core.c9891) __mptcp_destroy_sock (include/linux/kernel.h110) __mptcp_close (net/mptcp/protocol.c2959) mptcp_subflow_queue_clean (include/net/sock.h1777) __mptcp_close_ssk (net/mptcp/protocol.c2363) mptcp_destroy_common (net/mptcp/protocol.c3170) mptcp_destroy (include/net/sock.h1495) __mptcp_destroy_sock (net/mptcp/protocol.c2886) __mptcp_close (net/mptcp/protocol.c2959) mptcp_close (net/mptcp/protocol.c2974) inet_release (net/ipv4/af_inet.c432) __sock_release (net/socket.c651) sock_close (net/socket.c1367) __fput (fs/file_table.c320) task_work_run (kernel/task_work.c181 (discriminator 1)) exit_to_user_mode_prepare (include/linux/resume_user_mode.h49) syscall_exit_to_user_mode (kernel/entry/common.c130) do_syscall_64 (arch/x86/entry/common.c87) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S120) We cant call mptcp_close under the fast socket lock variant, replace it with a sock_lock_nested() as the relevant code is already under the listening msk socket lock protection.",
    "keyphrases": {
        "rootcause": "A sleep was called in atomic context within the mptcp_close function during socket closing, leading to a kernel panic.",
        "weakness": "The mptcp_close function was called under the fast socket lock, which does not allow sleeping. The function was attempting to sleep while holding a lock that requires atomic context.",
        "impact": "Kernel panic, system instability.",
        "vector": "Closing an MPTCP socket",
        "attacker": "Local user closing an mptcp socket.",
        "product": "Linux Kernel",
        "version": "6.1.0-rc5",
        "component": "Multipath TCP (MPTCP) Protocol"
    }
}
