{
  "cveId": "CVE-2022-49337",
  "version": "1.0.0",
  "timestamp": "2025-07-04T16:12:41.853043+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved ocfs2 dlmfs fix error handling of user_dlm_destroy_lock When user_dlm_destroy_lock failed, it didnt clean up the flags it set before exit. For USER_LOCK_IN_TEARDOWN, if this function fails because of lock is still in used, next time when unlink invokes this function, it will return succeed, and then unlink will remove inode and dentry if lock is not in used(file closed), but the dlm lock is still linked in dlm lock resource, then when bast come in, it will trigger a panic due to user-after-free. See the following panic call trace. To fix this, USER_LOCK_IN_TEARDOWN should be reverted if fail. And also error should be returned if USER_LOCK_IN_TEARDOWN is set to let user know that unlink fail. For the case of ocfs2_dlm_unlock failure, besides USER_LOCK_IN_TEARDOWN, USER_LOCK_BUSY is also required to be cleared. Even though spin lock is released in between, but USER_LOCK_IN_TEARDOWN is still set, for USER_LOCK_BUSY, if before every place that waits on this flag, USER_LOCK_IN_TEARDOWN is checked to bail out, that will make sure no flow waits on the busy flag set by user_dlm_destroy_lock(), then we can simplely revert USER_LOCK_BUSY when ocfs2_dlm_unlock fails. Fix user_dlm_cluster_lock() which is the only function not following this. [ 941.336392] (python,26174,16)dlmfs_unlink562 ERROR unlink 004fb0000060000b5a90b8c847b72e1, error -16 from destroy [ 989.757536] ------------[ cut here ]------------ [ 989.757709] kernel BUG at fs/ocfs2/dlmfs/userdlm.c173! [ 989.757876] invalid opcode 0000",
  "keyphrases": {
    "rootcause": "",
    "weakness": "user-after-free",
    "impact": [
      "kernel BUG",
      "panic"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "ocfs2"
  },
  "mitreTechnicalImpacts": []
}