{
    "cveId": "CVE-2022-49837",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved bpf Fix memory leaks in __check_func_call kmemleak reports this issue unreferenced object 0xffff88817139d000 (size 2048) comm test_progs, pid 33246, jiffies 4307381979 (age 45851.820s) hex dump (first 32 bytes) 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace [] kmalloc_trace+0x27/0xa0 [] __check_func_call+0x316/0x1230 [] check_helper_call+0x172e/0x4700 [] do_check+0x21d8/0x45e0 [] do_check_common+0x767/0xaf0 [] bpf_check+0x43e3/0x5bc0 [] bpf_prog_load+0xf26/0x1940 [] __sys_bpf+0xd2c/0x3650 [] __x64_sys_bpf+0x75/0xc0 [] do_syscall_64+0x3b/0x90 [] entry_SYSCALL_64_after_hwframe+0x63/0xcd The root case here is In function prepare_func_exit(), the callee is not released in the abnormal scenario after state->curframe--. To fix, move state->curframe-- to the very bottom of the function, right when we free callee and reset frame[] pointer to NULL, as Andrii suggested. In addition, function __check_func_call() has a similar problem. In the abnormal scenario before state->curframe++, the callee also should be released by free_func_state().",
    "keyphrases": {
        "component": "",
        "rootcause": "callee is not released after abnormal scenario",
        "vector": "",
        "weakness": "memory leak, unreferenced object",
        "product": "Linux kernel",
        "impact": "memory leak",
        "attacker": "",
        "version": ""
    }
}
