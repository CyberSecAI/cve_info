{
    "cveId": "CVE-2022-49080",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mm/mempolicy fix mpol_new leak in shared_policy_replace If mpol_new is allocated but not used in restart loop, mpol_new will be freed via mpol_put before returning to the caller. But refcnt is not initialized yet, so mpol_put could not do the right things and might leak the unused mpol_new. This would happen if mempolicy was updated on the shared shmem file while the sp->lock has been dropped during the memory allocation. This issue could be triggered easily with the below code snippet if there are many processes doing the below work at the same time shmid = shmget((key_t)5566, 1024 * PAGE_SIZE, 0666|IPC_CREAT) shm = shmat(shmid, 0, 0) loop many times { mbind(shm, 1024 * PAGE_SIZE, MPOL_LOCAL, mask, maxnode, 0) mbind(shm + 128 * PAGE_SIZE, 128 * PAGE_SIZE, MPOL_DEFAULT, mask, maxnode, 0) }",
    "keyphrases": {
        "rootcause": "refcnt not initialized before mpol_put",
        "weakness": "mempolicy update on shmem file while sp->lock dropped",
        "impact": "memory leak",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "mm/mempolicy fix mpol_new leak in shared_policy_replace"
    }
}
