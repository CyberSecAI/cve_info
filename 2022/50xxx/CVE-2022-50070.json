{
    "cveId": "CVE-2022-50070",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mptcp do not queue data on closed subflows Dipanjan reported a syzbot splat at close time WARNING CPU 1 PID 10818 at net/ipv4/af_inet.c153 inet_sock_destruct+0x6d0/0x8e0 net/ipv4/af_inet.c153 Modules linked in uio_ivshmem(OE) uio(E) CPU 1 PID 10818 Comm kworker/116 Tainted G OE 5.19.0-rc6-g2eae0556bb9d #2 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Workqueue events mptcp_worker RIP 0010inet_sock_destruct+0x6d0/0x8e0 net/ipv4/af_inet.c153 Code 21 02 00 00 41 8b 9c 24 28 02 00 00 e9 07 ff ff ff e8 34 4d 91 f9 89 ee 4c 89 e7 e8 4a 47 60 ff e9 a6 fc ff ff e8 20 4d 91 f9 0b e9 84 fe ff ff e8 14 4d 91 f9 0f 0b e9 d4 fd ff ff e8 08 4d RSP 0018ffffc9001b35fa78 EFLAGS 00010246 RAX 0000000000000000 RBX 00000000002879d0 RCX ffff8881326f3b00 RDX 0000000000000000 RSI ffff8881326f3b00 RDI 0000000000000002 RBP ffff888179662674 R08 ffffffff87e983a0 R09 0000000000000000 R10 0000000000000005 R11 00000000000004ea R12 ffff888179662400 R13 ffff888179662428 R14 0000000000000001 R15 ffff88817e38e258 FS 0000000000000000(0000) GSffff8881f5f00000(0000) knlGS0000000000000000 CS 0010 DS 0000 ES 0000 CR0 0000000080050033 CR2 0000000020007bc0 CR3 0000000179592000 CR4 0000000000150ee0 Call Trace __sk_destruct+0x4f/0x8e0 net/core/sock.c2067 sk_destruct+0xbd/0xe0 net/core/sock.c2112 __sk_free+0xef/0x3d0 net/core/sock.c2123 sk_free+0x78/0xa0 net/core/sock.c2134 sock_put include/net/sock.h1927 [inline] __mptcp_close_ssk+0x50f/0x780 net/mptcp/protocol.c2351 __mptcp_destroy_sock+0x332/0x760 net/mptcp/protocol.c2828 mptcp_worker+0x5d2/0xc90 net/mptcp/protocol.c2586 process_one_work+0x9cc/0x1650 kernel/workqueue.c2289 worker_thread+0x623/0x1070 kernel/workqueue.c2436 kthread+0x2e9/0x3a0 kernel/kthread.c376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S302 The root cause of the problem is that an mptcp-level (re)transmit can race with mptcp_close() and the packet scheduler checks the subflow state before acquiring the socket lock we can try to (re)transmit on an already closed ssk. Fix the issue checking again the subflow socket status under the subflow socket lock protection. Additionally add the missing check for the fallback-to-tcp case.",
    "keyphrases": {
        "rootcause": "mptcp-level transmit can race with mptcp_close() and the packet scheduler checks the subflow state before acquiring the socket lock",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "5.19.0-rc6",
        "component": "mptcp"
    }
}
