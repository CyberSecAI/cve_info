{
    "cveId": "CVE-2022-50086",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved block dont allow the same type rq_qos add more than once In our test of iocost, we encountered some list add/del corruptions of inner_walk list in ioc_timer_fn. The reason can be described as follows cpu 0 cpu 1 ioc_qos_write ioc_qos_write ioc = q_to_ioc(queue) if (!ioc) { ioc = kzalloc() ioc = q_to_ioc(queue) if (!ioc) { ioc = kzalloc() ... rq_qos_add(q, rqos) } ... rq_qos_add(q, rqos) ... } When the io.cost.qos file is written by two cpus concurrently, rq_qos may be added to one disk twice. In that case, there will be two iocs enabled and running on one disk. They own different iocgs on their active list. In the ioc_timer_fn function, because of the iocgs from two iocs have the same root iocg, the root iocgs walk_list may be overwritten by each other and this leads to list add/del corruptions in building or destroying the inner_walk list. And so far, the blk-rq-qos framework works in case that one instance for one type rq_qos per queue by default. This patch make this explicit and also fix the crash above.",
    "keyphrases": {
        "rootcause": "the same type rq_qos is added more than once",
        "weakness": "",
        "impact": "list add/del corruptions",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": ""
    }
}
