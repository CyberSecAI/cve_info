{
  "cveId": "CVE-2022-48763",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved KVM x86 Forcibly leave nested virt when SMM state is toggled Forcibly leave nested virtualization operation if userspace toggles SMM state via KVM_SET_VCPU_EVENTS or KVM_SYNC_X86_EVENTS. If userspace forces the vCPU out of SMM while its post-VMXON and then injects an SMI, vmx_enter_smm() will overwrite vmx->nested.smm.vmxon and end up with both vmxon=false and smm.vmxon=false, but all other nVMX state allocated. Dont attempt to gracefully handle the transition as (a) most transitions are nonsencial, e.g. forcing SMM while L2 is running, (b) there isnt sufficient information to handle all transitions, e.g. SVM wants access to the SMRAM save state, and (c) KVM_SET_VCPU_EVENTS must precede KVM_SET_NESTED_STATE during state restore as the latter disallows putting the vCPU into L2 if SMM is active, and disallows tagging the vCPU as being post-VMXON in SMM if SMM is not active. Abuse of KVM_SET_VCPU_EVENTS manifests as a WARN and memory leak in nVMX due to failure to free vmcs01s shadow VMCS, but the bug goes far beyond just a memory leak, e.g. toggling SMM on while L2 is active puts the vCPU in an architecturally impossible state. WARNING CPU 0 PID 3606 at free_loaded_vmcs arch/x86/kvm/vmx/vmx.c2665 [inline] WARNING CPU 0 PID 3606 at free_loaded_vmcs+0x158/0x1a0 arch/x86/kvm/vmx/vmx.c2656 Modules linked in CPU 1 PID 3606 Comm syz-executor725 Not tainted 5.17.0-rc1-syzkaller #0 Har",
  "keyphrases": {
    "rootcause": "improper state handling in vmx_enter_smm()",
    "weakness": "memory leak",
    "impact": "Forcibly leave nested virtualization operation",
    "vector": "toggling SMM state via KVM_SET_VCPU_EVENTS or KVM_SYNC_X86_EVENTS",
    "attacker": "userspace",
    "product": "Linux kernel",
    "version": "",
    "component": "KVM x86"
  },
  "mitreTechnicalImpacts": []
}