{
    "cveId": "CVE-2022-48830",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved can isotp fix potential CAN frame reception race in isotp_rcv() When receiving a CAN frame the current code logic does not consider concurrently receiving processes which do not show up in real world usage. Ziyang Xuan writes The following syz problem is one of the scenarios. so->rx.len is changed by isotp_rcv_ff() during isotp_rcv_cf(), so->rx.len equals 0 before alloc_skb() and equals 4096 after alloc_skb(). That will trigger skb_over_panic() in skb_put(). ======================================================= CPU 1 PID 19 Comm ksoftirqd/1 Not tainted 5.16.0-rc8-syzkaller #0 RIP 0010skb_panic+0x16c/0x16e net/core/skbuff.c113 Call Trace skb_over_panic net/core/skbuff.c118 [inline] skb_put.cold+0x24/0x24 net/core/skbuff.c1990 isotp_rcv_cf net/can/isotp.c570 [inline] isotp_rcv+0xa38/0x1e30 net/can/isotp.c668 deliver net/can/af_can.c574 [inline] can_rcv_filter+0x445/0x8d0 net/can/af_can.c635 can_receive+0x31d/0x580 net/can/af_can.c665 can_rcv+0x120/0x1c0 net/can/af_can.c696 __netif_receive_skb_one_core+0x114/0x180 net/core/dev.c5465 __netif_receive_skb+0x24/0x1b0 net/core/dev.c5579 Therefore we make sure the state changes and data structures stay consistent at CAN frame reception time by adding a spin_lock in isotp_rcv(). This fixes the issue reported by syzkaller but does not affect real world operation.",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "denial of service",
        "vector": "CAN frame reception",
        "attacker": "",
        "product": "Linux kernel",
        "version": "5.16.0-rc8",
        "component": "isotp_rcv()"
    }
}
