{
    "cveId": "CVE-2022-48719",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net, neigh Do not trigger immediate probes on NUD_FAILED from neigh_managed_work syzkaller was able to trigger a deadlock for NTF_MANAGED entries [0] kworker/016/14617 is trying to acquire lock ffffffff8d4dd370 (&tbl->lock){++-.}-{22}, at ___neigh_create+0x9e1/0x2990 net/core/neighbour.c652 [...] but task is already holding lock ffffffff8d4dd370 (&tbl->lock){++-.}-{22}, at neigh_managed_work+0x35/0x250 net/core/neighbour.c1572 The neighbor entry turned to NUD_FAILED state, where __neigh_event_send() triggered an immediate probe as per commit cd28ca0a3dd1 (neigh reduce arp latency) via neigh_probe() given table lock was held. One option to fix this situation is to defer the neigh_probe() back to the neigh_timer_handler() similarly as pre cd28ca0a3dd1. For the case of NTF_MANAGED, this deferral is acceptable given this only happens on actual failure state and regular / expected state is NUD_VALID with the entry already present. The fix adds a parameter to __neigh_event_send() in order to communicate whether immediate probe is allowed or disallowed. Existing call-sites of neigh_event_send() default as-is to immediate probe. However, the neigh_managed_work() disables it via use of neigh_event_send_probe(). [0] __dump_stack lib/dump_stack.c88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c106 print_deadlock_bug kernel/locking/lockdep.c2956 [inline] check_deadloc"
}
