{
    "cveId": "CVE-2022-48733",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs fix use-after-free after failure to create a snapshot At ioctl.ccreate_snapshot(), we allocate a pending snapshot structure and then attach it to the transactions list of pending snapshots. After that we call btrfs_commit_transaction(), and if that returns an error we jump to fail label, where we kfree() the pending snapshot structure. This can result in a later use-after-free of the pending snapshot 1) We allocated the pending snapshot and added it to the transactions list of pending snapshots 2) We call btrfs_commit_transaction(), and it fails either at the first call to btrfs_run_delayed_refs() or btrfs_start_dirty_block_groups(). In both cases, we dont abort the transaction and we release our transaction handle. We jump to the fail label and free the pending snapshot structure. We return with the pending snapshot still in the transactions list 3) Another task commits the transaction. This time theres no error at all, and then during the transaction commit it accesses a pointer to the pending snapshot structure that the snapshot creation task has already freed, resulting in a user-after-free. This issue could actually be detected by smatch, which produced the following warning fs/btrfs/ioctl.c843 create_snapshot() warn &pending_snapshot->list not removed from list So fix this by not having the snapshot creation ioctl directly add the pending sna",
    "keyphrases": {
        "rootcause": "use-after-free",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs"
    }
}
