{
    "cveId": "CVE-2022-48914",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved xen/netfront destroy queues before real_num_tx_queues is zeroed xennet_destroy_queues() relies on info->netdev->real_num_tx_queues to delete queues. Since d7dac083414eb5bb99a6d2ed53dc2c1b405224e5 (net-sysfs update the queue counts in the unregistration path), unregister_netdev() indirectly sets real_num_tx_queues to 0. Those two facts together means, that xennet_destroy_queues() called from xennet_remove() cannot do its job, because its called after unregister_netdev(). This results in kfree-ing queues that are still linked in napi, which ultimately crashes BUG kernel NULL pointer dereference, address 0000000000000000 #PF supervisor read access in kernel mode #PF error_code(0x0000) - not-present page PGD 0 P4D 0 Oops 0000 [#1] PREEMPT SMP PTI CPU 1 PID 52 Comm xenwatch Tainted G W 5.16.10-1.32.fc32.qubes.x86_64+ #226 RIP 0010free_netdev+0xa3/0x1a0 Code ff 48 89 df e8 2e e9 00 00 48 8b 43 50 48 8b 08 48 8d b8 a0 fe ff ff 48 8d a9 a0 fe ff ff 49 39 c4 75 26 eb 47 e8 ed c1 66 ff 8b 85 60 01 00 00 48 8d 95 60 01 00 00 48 89 ef 48 2d 60 01 00 RSP 0000ffffc90000bcfd00 EFLAGS 00010286 RAX 0000000000000000 RBX ffff88800edad000 RCX 0000000000000000 RDX 0000000000000001 RSI ffffc90000bcfc30 RDI 00000000ffffffff RBP fffffffffffffea0 R08 0000000000000000 R09 0000000000000000 R10 0000000000000000 R11 0000000000000001",
    "keyphrases": {
        "rootcause": "",
        "weakness": "use-after-free",
        "impact": "crash",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "xen/netfront"
    }
}
