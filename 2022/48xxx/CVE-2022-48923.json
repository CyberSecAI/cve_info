{
    "cveId": "CVE-2022-48923",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs prevent copying too big compressed lzo segment Compressed length can be corrupted to be a lot larger than memory we have allocated for buffer. This will cause memcpy in copy_compressed_segment to write outside of allocated memory. This mostly results in stuck read syscall but sometimes when using btrfs send can get #GP kernel general protection fault, probably for non-canonical address 0x841551d5c1000 0000 [#1] PREEMPT SMP NOPTI kernel CPU 17 PID 264 Comm kworker/u2567 Tainted P OE 5.17.0-rc2-1 #12 kernel Workqueue btrfs-endio btrfs_work_helper [btrfs] kernel RIP 0010lzo_decompress_bio (./include/linux/fortify-string.h225 fs/btrfs/lzo.c322 fs/btrfs/lzo.c394) btrfs Code starting with the faulting instruction =========================================== 0* 48 8b 06 mov (%rsi),%rax <-- trapping instruction 3 48 8d 79 08 lea 0x8(%rcx),%rdi 7 48 83 e7 f8 and $0xfffffffffffffff8,%rdi b 48 89 01 mov %rax,(%rcx) e 44 89 f0 mov %r14d,%eax 11 48 8b 54 06 f8 mov -0x8(%rsi,%rax,1),%rdx kernel RSP 0018ffffb110812efd50 EFLAGS 00010212 kernel RAX 0000000000001000 RBX 000000009ca264c8 RCX ffff98996e6d8ff8 kernel RDX 0000000000000064 RSI 000841551d5c1000 RDI ffffffff9500435d kernel RBP ffff989a3be856c",
    "keyphrases": {
        "rootcause": "",
        "weakness": "buffer overflow",
        "impact": "kernel general protection fault",
        "vector": "copying too big compressed lzo segment",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs"
    }
}
