{
    "cveId": "CVE-2022-48833",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs skip reserved bytes warning on unmount after log cleanup failure After the recent changes made by commit c2e39305299f01 (btrfs clear extent buffer uptodate when we fail to write it) and its followup fix, commit 651740a5024117 (btrfs check WRITE_ERR when trying to read an extent buffer), we can now end up not cleaning up space reservations of log tree extent buffers after a transaction abort happens, as well as not cleaning up still dirty extent buffers. This happens because if writeback for a log tree extent buffer failed, then we have cleared the bit EXTENT_BUFFER_UPTODATE from the extent buffer and we have also set the bit EXTENT_BUFFER_WRITE_ERR on it. Later on, when trying to free the log tree with free_log_tree(), which iterates over the tree, we can end up getting an -EIO error when trying to read a node or a leaf, since read_extent_buffer_pages() returns -EIO if an extent buffer does not have EXTENT_BUFFER_UPTODATE set and has the EXTENT_BUFFER_WRITE_ERR bit set. Getting that -EIO means that we return immediately as we can not iterate over the entire tree. In that case we never update the reserved space for an extent buffer in the respective block group and space_info object. When this happens we get the following traces when unmounting the fs [174957.284509] BTRFS error (device dm-0) in cleanup_transaction1913 errno=-5 IO failure [174957.286497] BTRFS error (device dm-0) in fre",
    "keyphrases": {
        "rootcause": "improper log tree extent buffer cleanup",
        "weakness": "",
        "impact": "IO failure",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs"
    }
}
