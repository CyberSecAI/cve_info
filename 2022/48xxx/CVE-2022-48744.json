{
    "cveId": "CVE-2022-48744",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net/mlx5e Avoid field-overflowing memcpy() In preparation for FORTIFY_SOURCE performing compile-time and run-time field bounds checking for memcpy(), memmove(), and memset(), avoid intentionally writing across neighboring fields. Use flexible arrays instead of zero-element arrays (which look like they are always overflowing) and split the cross-field memcpy() into two halves that can be appropriately bounds-checked by the compiler. We were doing #define ETH_HLEN 14 #define VLAN_HLEN 4 ... #define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN) ... struct mlx5e_tx_wqe *wqe = mlx5_wq_cyc_get_wqe(wq, pi) ... struct mlx5_wqe_eth_seg *eseg = &wqe->eth struct mlx5_wqe_data_seg *dseg = wqe->data ... memcpy(eseg->inline_hdr.start, xdptxd->data, MLX5E_XDP_MIN_INLINE) target is wqe->eth.inline_hdr.start (which the compiler sees as being 2 bytes in size), but copying 18, intending to write across start (really vlan_tci, 2 bytes). The remaining 16 bytes get written into wqe->data[0], covering byte_count (4 bytes), lkey (4 bytes), and addr (8 bytes). struct mlx5e_tx_wqe { struct mlx5_wqe_ctrl_seg ctrl /* 0 16 */ struct mlx5_wqe_eth_seg eth /* 16 16 */ struct mlx5_wqe_data_seg data[] /* 32 0 */ /* size 32, cachelines 1, members 3 */ /* last cacheline 32 bytes */",
    "keyphrases": {
        "rootcause": "",
        "weakness": "field-overflowing memcpy()",
        "impact": "write across fields",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "net/mlx5e"
    }
}
