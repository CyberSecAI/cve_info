{
  "cveId": "CVE-2022-48983",
  "version": "1.0.0",
  "timestamp": "2024-12-18T22:42:50.929578+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved io_uring Fix a null-ptr-deref in io_tctx_exit_cb() Syzkaller reports a NULL deref bug as follows BUG KASAN null-ptr-deref in io_tctx_exit_cb+0x53/0xd3 Read of size 4 at addr 0000000000000138 by task file1/1955 CPU 1 PID 1955 Comm file1 Not tainted 6.1.0-rc7-00103-gef4d3ea40565 #75 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04/01/2014 Call Trace dump_stack_lvl+0xcd/0x134 ? io_tctx_exit_cb+0x53/0xd3 kasan_report+0xbb/0x1f0 ? io_tctx_exit_cb+0x53/0xd3 kasan_check_range+0x140/0x190 io_tctx_exit_cb+0x53/0xd3 task_work_run+0x164/0x250 ? task_work_cancel+0x30/0x30 get_signal+0x1c3/0x2440 ? lock_downgrade+0x6e0/0x6e0 ? lock_downgrade+0x6e0/0x6e0 ? exit_signals+0x8b0/0x8b0 ? do_raw_read_unlock+0x3b/0x70 ? do_raw_spin_unlock+0x50/0x230 arch_do_signal_or_restart+0x82/0x2470 ? kmem_cache_free+0x260/0x4b0 ? putname+0xfe/0x140 ? get_sigframe_size+0x10/0x10 ? do_execveat_common.isra.0+0x226/0x710 ? lockdep_hardirqs_on+0x79/0x100 ? putname+0xfe/0x140 ? do_execveat_common.isra.0+0x238/0x710 exit_to_user_mode_prepare+0x15f/0x250 syscall_exit_to_user_mode+0x19/0x50 do_syscall_64+0x42/0xb0 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP 00230x0 Code Unable to access opcode bytes at 0xffffffffffffffd6. RSP 002b00000000fffb7790 EFLAGS 00000200 ORIG_RAX 000000000000000b RAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000000 RDX 0000000000000000 RSI 0000000000000000 RDI 0000000000000000 RBP 0000000000000000 R08 0000000000000000 R09 0000000000000000 R10 0000000000000000 R11 0000000000000000 R12 0000000000000000 R13 0000000000000000 R14 0000000000000000 R15 0000000000000000 Kernel panic - not syncing panic_on_warn set ... This happens because the adding of task_work from io_ring_exit_work() isnt synchronized with canceling all work items from eg exec. The execution of the two are ordered in that they are both run by the task itself, but if io_tctx_exit_cb() is queued while were canceling all work items off exec AND gets executed when the task exits to userspace rather than in the main loop in io_uring_cancel_generic(), then we can find current->io_uring == NULL and hit the above crash. Its safe to add this NULL check here, because the execution of the two paths are done by the task itself. [axboe add code comment and also put an explanation in the commit msg]",
  "keyphrases": {
    "rootcause": "",
    "weakness": "null-ptr-deref",
    "impact": [
      "Kernel panic",
      "information disclosure"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "io_uring"
  },
  "mitreTechnicalImpacts": []
}