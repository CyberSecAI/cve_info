{
    "cveId": "CVE-2022-48909",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net/smc fix connection leak Theres a potential leak issue under following execution sequence smc_release smc_connect_work if (sk->sk_state == SMC_INIT) send_clc_confirim tcp_abort() ... sk.sk_state = SMC_ACTIVE smc_close_active switch(sk->sk_state) { ... case SMC_ACTIVE smc_close_final() // then wait peer closed Unfortunately, tcp_abort() may discard CLC CONFIRM messages that are still in the tcp send buffer, in which case our connection token cannot be delivered to the server side, which means that we cannot get a passive close message at all. Therefore, it is impossible for the to be disconnected at all. This patch tries a very simple way to avoid this issue, once the state has changed to SMC_ACTIVE after tcp_abort(), we can actively abort the smc connection, considering that the state is SMC_INIT before tcp_abort(), abandoning the complete disconnection process should not cause too much problem. In fact, this problem may exist as long as the CLC CONFIRM message is not received by the server. Whether a timer should be added after smc_close_final() needs to be discussed in the future. But even so, this patch provides a faster release for connection in above case, it should also be valuable.",
    "keyphrases": {
        "rootcause": "",
        "weakness": "potential leak issue",
        "impact": "cannot be delivered to the server side",
        "vector": "following execution sequence",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "net/smc"
    }
}
