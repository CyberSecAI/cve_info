{
  "cveId": "CVE-2023-52761",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved riscv VMAP_STACK overflow detection thread-safe commit 31da94c25aea (riscv add VMAP_STACK overflow detection) added support for CONFIG_VMAP_STACK. If overflow is detected, CPU switches to `shadow_stack` temporarily before switching finally to per-cpu `overflow_stack`. If two CPUs/harts are racing and end up in over flowing kernel stack, one or both will end up corrupting each other state because `shadow_stack` is not per-cpu. This patch optimizes per-cpu overflow stack switch by directly picking per-cpu `overflow_stack` and gets rid of `shadow_stack`. Following are the changes in this patch - Defines an asm macro to obtain per-cpu symbols in destination register. - In entry.S, when overflow is detected, per-cpu overflow stack is located using per-cpu asm macro. Computing per-cpu symbol requires a temporary register. x31 is saved away into CSR_SCRATCH (CSR_SCRATCH is anyways zero since were in kernel). Please see Links for additional relevant disccussion and alternative solution. Tested by `echo EXHAUST_STACK > /sys/kernel/debug/provoke-crash/DIRECT` Kernel crash log below Insufficient stack space to handle exception!/debug/provoke-crash/DIRECT Task stack [0xff20000010a98000..0xff20000010a9c000] Overflow stack [0xff600001f7d98370..0xff600001f7d99370] CPU 1 PID 205 Comm bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34 Hardware name riscv-virtio,qemu (DT) epc __mems",
  "keyphrases": {
    "rootcause": "race condition",
    "weakness": "stack overflow",
    "impact": "Kernel crash",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "riscv",
    "component": ""
  },
  "mitreTechnicalImpacts": []
}