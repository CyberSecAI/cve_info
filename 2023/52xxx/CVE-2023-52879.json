{
  "cveId": "CVE-2023-52879",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved tracing Have trace_event_file have ref counters The following can crash the kernel # cd /sys/kernel/tracing # echo psched schedule > kprobe_events # exec 5>>events/kprobes/sched/enable # > kprobe_events # exec 5>&- The above commands 1. Change directory to the tracefs directory 2. Create a kprobe event (doesnt matter what one) 3. Open bash file descriptor 5 on the enable file of the kprobe event 4. Delete the kprobe event (removes the files too) 5. Close the bash file descriptor 5 The above causes a crash! BUG kernel NULL pointer dereference, address 0000000000000028 #PF supervisor read access in kernel mode #PF error_code(0x0000) - not-present page PGD 0 P4D 0 Oops 0000 [#1] PREEMPT SMP PTI CPU 6 PID 877 Comm bash Not tainted 6.5.0-rc4-test-00008-g2c6b6b1029d4-dirty #186 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 RIP 0010tracing_release_file_tr+0xc/0x50 What happens here is that the kprobe event creates a trace_event_file file descriptor that represents the file in tracefs to the event. It maintains state of the event (is it enabled for the given instance?). Opening the enable file gets a reference to the event file descriptor via the open file descriptor. When the kprobe event is deleted, the file is also deleted from the tracefs system which also frees the event file descriptor. But as the tracefs file is st",
  "keyphrases": {
    "rootcause": "BUG kernel NULL pointer dereference",
    "weakness": "",
    "impact": [
      "Oops",
      "crash the kernel",
      "read access"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "6.5.0-rc4-test-00008-g2c6b6b1029d4-dirty",
    "component": ""
  },
  "mitreTechnicalImpacts": []
}