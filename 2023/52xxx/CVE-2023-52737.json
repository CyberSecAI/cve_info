{
    "cveId": "CVE-2023-52737",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs lock the inode in shared mode before starting fiemap Currently fiemap does not take the inodes lock (VFS lock), it only locks a file range in the inodes io tree. This however can lead to a deadlock if we have a concurrent fsync on the file and fiemap code triggers a fault when accessing the user space buffer with fiemap_fill_next_extent(). The deadlock happens on the inodes i_mmap_lock semaphore, which is taken both by fsync and btrfs_page_mkwrite(). This deadlock was recently reported by syzbot and triggers a trace like the following tasksyz-executor361 stateD stack20264 pid5668 ppid5119 flags0x00004004 Call Trace context_switch kernel/sched/core.c5293 [inline] __schedule+0x995/0xe20 kernel/sched/core.c6606 schedule+0xcb/0x190 kernel/sched/core.c6682 wait_on_state fs/btrfs/extent-io-tree.c707 [inline] wait_extent_bit+0x577/0x6f0 fs/btrfs/extent-io-tree.c751 lock_extent+0x1c2/0x280 fs/btrfs/extent-io-tree.c1742 find_lock_delalloc_range+0x4e6/0x9c0 fs/btrfs/extent_io.c488 writepage_delalloc+0x1ef/0x540 fs/btrfs/extent_io.c1863 __extent_writepage+0x736/0x14e0 fs/btrfs/extent_io.c2174 extent_write_cache_pages+0x983/0x1220 fs/btrfs/extent_io.c3091 extent_writepages+0x219/0x540 fs/btrfs/extent_io.c3211 do_writepages+0x3c3/0x680 mm/page-writeback.c2581 filemap_fdatawrite_wbc+0x11e/0x170 mm/filemap.c388 __fi",
    "keyphrases": {
        "rootcause": "lack of lock acquisition",
        "weakness": "deadlock",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs fiemap"
    }
}
