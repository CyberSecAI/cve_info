{
    "cveId": "CVE-2023-52452",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved bpf Fix accesses to uninit stack slots Privileged programs are supposed to be able to read uninitialized stack memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already large enough, the access was permitted, but otherwise the access was rejected instead of being allowed to grow the stack. This undesired rejection was happening in two places - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldnt be updated - global_func16 - because it cant run unprivileged for other reasons. This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because theyre inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the functions needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small s",
    "keyphrases": {
        "rootcause": "accesses to uninit stack slots were permitted inconsistently",
        "weakness": "",
        "impact": "out-of-bounds data read",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "bpf"
    }
}
