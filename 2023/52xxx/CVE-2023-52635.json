{
    "cveId": "CVE-2023-52635",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved PM / devfreq Synchronize devfreq_monitor_[start/stop] There is a chance if a frequent switch of the governor done in a loop result in timer list corruption where timer cancel being done from two place one from cancel_delayed_work_sync() and followed by expire_timers() can be seen from the traces[1]. while true do echo simple_ondemand > /sys/class/devfreq/1d84000.ufshc/governor echo performance > /sys/class/devfreq/1d84000.ufshc/governor done It looks to be issue with devfreq driver where device_monitor_[start/stop] need to synchronized so that delayed work should get corrupted while it is either being queued or running or being cancelled. Lets use polling flag and devfreq lock to synchronize the queueing the timer instance twice and work data being corrupted. [1] ... .. -0 [003] 9436.209662 timer_cancel timer=0xffffff80444f0428 -0 [003] 9436.209664 timer_expire_entry timer=0xffffff80444f0428 now=0x10022da1c function=__typeid__ZTSFvP10timer_listE_global_addr baseclk=0x10022da1c -0 [003] 9436.209718 timer_expire_exit timer=0xffffff80444f0428 kworker/u166-14217 [003] 9436.209863 timer_start timer=0xffffff80444f0428 function=__typeid__ZTSFvP10timer_listE_global_addr expires=0x10022da2b now=0x10022da1c flags=182452227 vendor.xxxyyy.ha-1593 [004] 9436.209888 timer_cancel timer=0xffffff80444f0428 vendor.xxxyyy.ha-1593",
    "keyphrases": {
        "rootcause": "unsynchronized access",
        "weakness": "race condition",
        "impact": "timer list corruption",
        "vector": "frequent switch of the governor in a loop",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "PM / devfreq"
    }
}
