{
    "cveId": "CVE-2023-52903",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvedio_uring lock overflowing for IOPOLLsyzbot reports an issue with overflow filling for IOPOLLWARNING CPU 0 PID 28 at io_uring/io_uring.c734 io_cqring_event_overflow+0x1c0/0x230 io_uring/io_uring.c734CPU 0 PID 28 Comm kworker/u41 Not tainted 6.2.0-rc3-syzkaller-16369-g358a161a6a9e #0Workqueue events_unbound io_ring_exit_workCall traceio_cqring_event_overflow+0x1c0/0x230 io_uring/io_uring.c734io_req_cqe_overflow+0x5c/0x70 io_uring/io_uring.c773io_fill_cqe_req io_uring/io_uring.h168 [inline]io_do_iopoll+0x474/0x62c io_uring/rw.c1065io_iopoll_try_reap_events+0x6c/0x108 io_uring/io_uring.c1513io_uring_try_cancel_requests+0x13c/0x258 io_uring/io_uring.c3056io_ring_exit_work+0xec/0x390 io_uring/io_uring.c2869process_one_work+0x2d8/0x504 kernel/workqueue.c2289worker_thread+0x340/0x610 kernel/workqueue.c2436kthread+0x12c/0x158 kernel/kthread.c376ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S863There is no real problem for normal IOPOLL as flush is also called withuring_lock taken, but its getting more complicated for IOPOLL|SQPOLL,for which __io_cqring_overflow_flush() happens from the CQ waiting path.",
    "keyphrases": {
        "rootcause": "io_uring lock overflowing",
        "weakness": "Improper handling of io_uring lock during IOPOLL and SQPOLL operations",
        "impact": "Potential for race conditions and system instability",
        "vector": "Exploitation via crafted IOPOLL and SQPOLL requests",
        "attacker": "Local user",
        "product": "Linux Kernel",
        "version": "6.2.0-rc3",
        "component": "io_uring"
    }
}
