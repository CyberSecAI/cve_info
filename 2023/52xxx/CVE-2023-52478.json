{
    "cveId": "CVE-2023-52478",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved HID logitech-hidpp Fix kernel crash on receiver USB disconnect hidpp_connect_event() has *four* time-of-check vs time-of-use (TOCTOU) races when it races with itself. hidpp_connect_event() primarily runs from a workqueue but it also runs on probe() and if a device-connected packet is received by the hw when the thread running hidpp_connect_event() from probe() is waiting on the hw, then a second thread running hidpp_connect_event() will be started from the workqueue. This opens the following races (note the below code is simplified) 1. Retrieving + printing the protocol (harmless race) if (!hidpp->protocol_major) { hidpp_root_get_protocol_version() hidpp->protocol_major = response.rap.params[0] } We can actually see this race hit in the dmesg in the abrt output attached to rhbz#2227968 [ 3064.624215] logitech-hidpp-device 0003046D4071.0049 HID++ 4.5 device connected. [ 3064.658184] logitech-hidpp-device 0003046D4071.0049 HID++ 4.5 device connected. Testing with extra logging added has shown that after this the 2 threads take turn grabbing the hw access mutex (send_mutex) so they ping-pong through all the other TOCTOU cases managing to hit all of them 2. Updating the name to the HIDPP name (harmless race) if (hidpp->name == hdev->name) { ... hidpp->name = new_name } 3. Initializing the power_supply class for the battery (problematic!) hidpp_initialize_battery() { if (hidp",
    "keyphrases": {
        "rootcause": "time-of-check vs time-of-use (TOCTOU) race",
        "weakness": "",
        "impact": "kernel crash",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "hidpp_connect_event()"
    }
}
