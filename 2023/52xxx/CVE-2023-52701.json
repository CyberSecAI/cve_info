{
  "cveId": "CVE-2023-52701",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved net use a bounce buffer for copying skb->mark syzbot found arm64 builds would crash in sock_recv_mark() when CONFIG_HARDENED_USERCOPY=y x86 and powerpc are not detecting the issue because they define user_access_begin. This will be handled in a different patch, because a check_object_size() is missing. Only data from skb->cb[] can be copied directly to/from user space, as explained in commit 79a8a642bf05 (net Whitelist the skbuff_head_cache cb field) syzbot report was usercopy Kernel memory exposure attempt detected from SLUB object skbuff_head_cache (offset 168, size 4)! ------------[ cut here ]------------ kernel BUG at mm/usercopy.c102 ! Internal error Oops - BUG 00000000f2000800 [#1] PREEMPT SMP Modules linked in CPU 0 PID 4410 Comm syz-executor533 Not tainted 6.2.0-rc7-syzkaller-17907-g2d3827b3f393 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/21/2023 pstate 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc usercopy_abort+0x90/0x94 mm/usercopy.c90 lr usercopy_abort+0x90/0x94 mm/usercopy.c90 sp ffff80000fb9b9a0 x29 ffff80000fb9b9b0 x28 ffff0000c6073400 x27 0000000020001a00 x26 0000000000000014 x25 ffff80000cf52000 x24 fffffc0000000000 x23 05ffc00000000200 x22 fffffc000324bf80 x21 ffff0000c92fe1a8 x20 0000000000000001 x19 0000000000000004 x18 0000000000000000 x17 656a626f2042554c x16 ffff0000c6073dd0 x15 ffff80000",
  "keyphrases": {
    "rootcause": "missing check_object_size()",
    "weakness": "buffer underflow",
    "impact": [
      "Oops",
      "crash",
      "kernel BUG"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "sock_recv_mark()"
  },
  "mitreTechnicalImpacts": []
}