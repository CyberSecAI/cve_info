{
    "cveId": "CVE-2021-47092",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved KVM VMX Always clear vmx->fail on emulation_required Revert a relatively recent change that set vmx->fail if the vCPU is in L2 and emulation_required is true, as that behavior is completely bogus. Setting vmx->fail and synthesizing a VM-Exit is contradictory and wrong (a) its impossible to have both a VM-Fail and VM-Exit (b) vmcs.EXIT_REASON is not modified on VM-Fail (c) emulation_required refers to guest state and guest state checks are always VM-Exits, not VM-Fails. For KVM specifically, emulation_required is handled before nested exits in __vmx_handle_exit(), thus setting vmx->fail has no immediate effect, i.e. KVM calls into handle_invalid_guest_state() and vmx->fail is ignored. Setting vmx->fail can ultimately result in a WARN in nested_vmx_vmexit() firing when tearing down the VM as KVM never expects vmx->fail to be set when L2 is active, KVM always reflects those errors into L1. ------------[ cut here ]------------ WARNING CPU 0 PID 21158 at arch/x86/kvm/vmx/nested.c4548 nested_vmx_vmexit+0x16bd/0x17e0 arch/x86/kvm/vmx/nested.c4547 Modules linked in CPU 0 PID 21158 Comm syz-executor.1 Not tainted 5.16.0-rc3-syzkaller #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 RIP 0010nested_vmx_vmexit+0x16bd/0x17e0 arch/x86/kvm/vmx/nested.c4547 Code 0b e",
    "keyphrases": {
        "rootcause": "improper vmx->fail setting",
        "weakness": "",
        "impact": "denial of service",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "5.16.0-rc3",
        "component": "KVM VMX"
    }
}
