{
    "cveId": "CVE-2021-47209",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved sched/fair Prevent dead task groups from regaining cfs_rqs Kevin is reporting crashes which point to a use-after-free of a cfs_rq in update_blocked_averages(). Initial debugging revealed that weve live cfs_rqs (on_list=1) in an about to be kfree()d task group in free_fair_sched_group(). However, it was unclear how that can happen. His kernel config happened to lead to a layout of struct sched_entity that put the my_q member directly into the middle of the object which makes it incidentally overlap with SLUBs freelist pointer. That, in combination with SLAB_FREELIST_HARDENEDs freelist pointer mangling, leads to a reliable access violation in form of a #GP which made the UAF fail fast. Michal seems to have run into the same issue[1]. He already correctly diagnosed that commit a7b359fc6a37 (sched/fair Correctly insert cfs_rqs to list on unthrottle) is causing the preconditions for the UAF to happen by re-adding cfs_rqs also to task groups that have no more running tasks, i.e. also to dead ones. His analysis, however, misses the real root cause and it cannot be seen from the crash backtrace only, as the real offender is tg_unthrottle_up() getting called via sched_cfs_period_timer() via the timer interrupt at an inconvenient time. When unregister_fair_sched_group() unlinks all cfs_rqs from the dying task group, it doesnt protect itself from getting interrupted. If the timer interrupt triggers",
    "keyphrases": {
        "rootcause": "use-after-free",
        "weakness": "",
        "impact": "access violation",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "sched/fair"
    }
}
