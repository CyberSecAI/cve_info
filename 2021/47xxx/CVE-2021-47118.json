{
    "cveId": "CVE-2021-47118",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved pid take a reference when initializing `cad_pid` During boot, kernel_init_freeable() initializes `cad_pid` to the init tasks struct pid. Later on, we may change `cad_pid` via a sysctl, and when this happens proc_do_cad_pid() will increment the refcount on the new pid via get_pid(), and will decrement the refcount on the old pid via put_pid(). As we never called get_pid() when we initialized `cad_pid`, we decrement a reference we never incremented, can therefore free the init tasks struct pid early. As there can be dangling references to the struct pid, we can later encounter a use-after-free (e.g. when delivering signals). This was spotted when fuzzing v5.13-rc3 with Syzkaller, but seems to have been around since the conversion of `cad_pid` to struct pid in commit 9ec52099e4b8 ([PATCH] replace cad_pid by a struct pid) from the pre-KASAN stone age of v2.6.19. Fix this by getting a reference to the init tasks struct pid when we assign it to `cad_pid`. Full KASAN splat below. ================================================================== BUG KASAN use-after-free in ns_of_pid include/linux/pid.h153 [inline] BUG KASAN use-after-free in task_active_pid_ns+0xc0/0xc8 kernel/pid.c509 Read of size 4 at addr ffff23794dda0004 by task syz-executor.0/273 CPU 1 PID 273 Comm syz-executor.0 Not tainted 5.12.0-00001-g9aef892b2d15 #1 Hardware name linux,dummy-virt (DT) Call tr",
    "keyphrases": {
        "rootcause": "decrementing a reference that was never incremented",
        "weakness": "use-after-free",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "v5.13-rc3",
        "component": "cad_pid"
    }
}
