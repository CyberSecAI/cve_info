{
    "cveId": "CVE-2021-47011",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mm memcontrol slab fix obtain a reference to a freeing memcg Patch series Use obj_cgroup APIs to charge kmem pages, v5. Since Romans series The new cgroup slab memory controller applied. All slab objects are charged with the new APIs of obj_cgroup. The new APIs introduce a struct obj_cgroup to charge slab objects. It prevents long-living objects from pinning the original memory cgroup in the memory. But there are still some corner objects (e.g. allocations larger than order-1 page on SLUB) which are not charged with the new APIs. Those objects (include the pages which are allocated from buddy allocator directly) are charged as kmem pages which still hold a reference to the memory cgroup. E.g. We know that the kernel stack is charged as kmem pages because the size of the kernel stack can be greater than 2 pages (e.g. 16KB on x86_64 or arm64). If we create a thread (suppose the thread stack is charged to memory cgroup A) and then move it from memory cgroup A to memory cgroup B. Because the kernel stack of the thread hold a reference to the memory cgroup A. The thread can pin the memory cgroup A in the memory even if we remove the cgroup A. If we want to see this scenario by using the following script. We can see that the system has added 500 dying cgroups (This is not a real world issue, just a script to show that the large kmallocs are charged as kmem pages which can pin the memory cgro",
    "keyphrases": {
        "rootcause": "",
        "weakness": "struct obj_cgroup to charge slab objects",
        "impact": "pin the memory cgroup",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "5.11",
        "component": ""
    }
}
