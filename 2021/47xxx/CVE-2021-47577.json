{
    "cveId": "CVE-2021-47577",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved io-wq check for wq exit after adding new worker task_work We check IO_WQ_BIT_EXIT before attempting to create a new worker, and wq exit cancels pending work if we have any. But its possible to have a race between the two, where creation checks exit finding it not set, but were in the process of exiting. The exit side will cancel pending creation task_work, but theres a gap where we add task_work after weve canceled existing creations at exit time. Fix this by checking the EXIT bit post adding the creation task_work. If its set, run the same cancelation that exit does.",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "",
        "vector": "create a new worker",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": ""
    }
}
