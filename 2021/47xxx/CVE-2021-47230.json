{
  "cveId": "CVE-2021-47230",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved KVM x86 Immediately reset the MMU context when the SMM flag is cleared Immediately reset the MMU context when the vCPUs SMM flag is cleared so that the SMM flag in the MMU role is always synchronized with the vCPUs flag. If RSM fails (which isnt correctly emulated), KVM will bail without calling post_leave_smm() and leave the MMU in a bad state. The bad MMU role can lead to a NULL pointer dereference when grabbing a shadow pages rmap for a page fault as the initial lookups for the gfn will happen with the vCPUs SMM flag (=0), whereas the rmap lookup will use the shadow pages SMM flag, which comes from the MMU (=1). SMM has an entirely different set of memslots, and so the initial lookup can find a memslot (SMM=0) and then explode on the rmap memslot lookup (SMM=1). general protection fault, probably for non-canonical address 0xdffffc0000000000 0000 [#1] PREEMPT SMP KASAN KASAN null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU 1 PID 8410 Comm syz-executor382 Not tainted 5.13.0-rc5-syzkaller #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 RIP 0010__gfn_to_rmap arch/x86/kvm/mmu/mmu.c935 [inline] RIP 0010gfn_to_rmap+0x2b0/0x4d0 arch/x86/kvm/mmu/mmu.c947 Code 80 3c 20 00 74 08 4c 89 ff e8 f1 79 a9 00 4c 89 fb 4d 8b 37 44 RSP 0018ffffc90000ffef98 EFLAGS 00010246 RAX 0000000000000000 RBX ffff888015b9f",
  "keyphrases": {
    "rootcause": "",
    "weakness": [
      "NULL pointer dereference",
      "null-ptr-deref"
    ],
    "impact": "general protection fault",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "5.13.0-rc5",
    "component": "KVM"
  },
  "mitreTechnicalImpacts": []
}