{
    "cveId": "CVE-2021-47391",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved RDMA/cma Ensure rdma_addr_cancel() happens before issuing more requests The FSM can run in a circle allowing rdma_resolve_ip() to be called twice on the same id_priv. While this cannot happen without going through the work, it violates the invariant that the same address resolution background request cannot be active twice. CPU 1 CPU 2 rdma_resolve_addr() RDMA_CM_IDLE -> RDMA_CM_ADDR_QUERY rdma_resolve_ip(addr_handler) #1 process_one_req() for #1 addr_handler() RDMA_CM_ADDR_QUERY -> RDMA_CM_ADDR_BOUND mutex_unlock(&id_priv->handler_mutex) [.. handler still running ..] rdma_resolve_addr() RDMA_CM_ADDR_BOUND -> RDMA_CM_ADDR_QUERY rdma_resolve_ip(addr_handler) !! two requests are now on the req_list rdma_destroy_id() destroy_id_handler_unlock() _destroy_id() cma_cancel_operation() rdma_addr_cancel() // process_one_req() self removes it spin_lock_bh(&lock) cancel_delayed_work(&req->work) if (!list_empty(&req->list)) == true ! rdma_addr_cancel() returns after process_on_req #1 is done kfree(id_priv) process_one_req() for #2 addr_handler() mutex_lock(&id_priv->handler_mutex)",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "violation of invariant",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "RDMA/cma"
    }
}
