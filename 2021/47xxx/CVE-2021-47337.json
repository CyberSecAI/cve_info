{
  "cveId": "CVE-2021-47337",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved scsi core Fix bad pointer dereference when ehandler kthread is invalid Commit 66a834d09293 (scsi core Fix error handling of scsi_host_alloc()) changed the allocation logic to call put_device() to perform host cleanup with the assumption that IDA removal and stopping the kthread would properly be performed in scsi_host_dev_release(). However, in the unlikely case that the error handler thread fails to spawn, shost->ehandler is set to ERR_PTR(-ENOMEM). The error handler cleanup code in scsi_host_dev_release() will call kthread_stop() if shost->ehandler != NULL which will always be the case whether the kthread was successfully spawned or not. In the case that it failed to spawn this has the nasty side effect of trying to dereference an invalid pointer when kthread_stop() is called. The following splat provides an example of this behavior in the wild scsi host11 error handler thread failed to spawn, error = -4 Kernel attempted to read user page (10c) - exploit attempt? (uid 0) BUG Kernel NULL pointer dereference on read at 0x0000010c Faulting instruction address 0xc00000000818e9a8 Oops Kernel access of bad area, sig 11 [#1] LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries Modules linked in ibmvscsi(+) scsi_transport_srp dm_multipath dm_mirror dm_region hash dm_log dm_mod fuse overlay squashfs loop CPU 12 PID 274 Comm systemd-udevd Not tainted 5.13.0-rc7 #1 NIP c00000000818e9a8 LR c",
  "keyphrases": {
    "rootcause": "improper cleanup in scsi_host_dev_release",
    "weakness": "NULL pointer dereference",
    "impact": "Oops",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "scsi core"
  },
  "mitreTechnicalImpacts": []
}