{
  "cveId": "CVE-2021-47553",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved sched/scs Reset task stack state in bringup_cpu() To hot unplug a CPU, the idle task on that CPU calls a few layers of C code before finally leaving the kernel. When KASAN is in use, poisoned shadow is left around for each of the active stack frames, and when shadow call stacks are in use. When shadow call stacks (SCS) are in use the tasks saved SCS SP is left pointing at an arbitrary point within the tasks shadow call stack. When a CPU is offlined than onlined back into the kernel, this stale state can adversely affect execution. Stale KASAN shadow can alias new stackframes and result in bogus KASAN warnings. A stale SCS SP is effectively a memory leak, and prevents a portion of the shadow call stack being used. Across a number of hotplug cycles the idle tasks entire shadow call stack can become unusable. We previously fixed the KASAN issue in commit e1b77c92981a5222 (sched/kasan remove stale KASAN poison after hotplug) ... by removing any stale KASAN stack poison immediately prior to onlining a CPU. Subsequently in commit f1a0a376ca0c4ef1 (sched/core Initialize the idle task with preemption disabled) ... the refactoring left the KASAN and SCS cleanup in one-time idle thread initialization code rather than something invoked prior to each CPU being onlined, breaking both as above. We fixed SCS (but not KASAN) in commit 63acd42c0d4942f7 (sched/scs Reset the shadow stack when idl",
  "keyphrases": {
    "rootcause": "stale KASAN shadow and SCS SP",
    "weakness": "memory leak",
    "impact": "bogus KASAN warnings",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "sched/scs"
  },
  "mitreTechnicalImpacts": []
}