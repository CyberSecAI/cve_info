{
    "cveId": "CVE-2021-47448",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mptcp fix possible stall on recvmsg() recvmsg() can enter an infinite loop if the caller provides the MSG_WAITALL, the data present in the receive queue is not sufficient to fulfill the request, and no more data is received by the peer. When the above happens, mptcp_wait_data() will always return with no wait, as the MPTCP_DATA_READY flag checked by such function is set and never cleared in such code path. Leveraging the above syzbot was able to trigger an RCU stall rcu INFO rcu_preempt self-detected stall on CPU rcu 0-...! (10499 ticks this GP) idle=0af/1/0x4000000000000000 softirq=10678/10678 fqs=1 (t=10500 jiffies g=13089 q=109) rcu rcu_preempt kthread starved for 10497 jiffies! g13089 f0x0 RCU_GP_WAIT_FQS(5) ->state=0x0 ->cpu=1 rcu Unless rcu_preempt kthread gets sufficient CPU time, OOM is now expected behavior. rcu RCU grace-period kthread stack dump taskrcu_preempt stateR running task stack28696 pid 14 ppid 2 flags0x00004000 Call Trace context_switch kernel/sched/core.c4955 [inline] __schedule+0x940/0x26f0 kernel/sched/core.c6236 schedule+0xd3/0x270 kernel/sched/core.c6315 schedule_timeout+0x14a/0x2a0 kernel/time/timer.c1881 rcu_gp_fqs_loop+0x186/0x810 kernel/rcu/tree.c1955 rcu_gp_kthread+0x1de/0x320 kernel/rcu/tree.c2128 kthread+0x405/0x4f0 kernel/kthread.c327 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S295 rcu Stack dump where R"
}
