{
    "cveId": "CVE-2021-47103",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved inet fully convert sk->sk_rx_dst to RCU rules syzbot reported various issues around early demux, one being included in this changelog [1] sk->sk_rx_dst is using RCU protection without clearly documenting it. And following sequences in tcp_v4_do_rcv()/tcp_v6_do_rcv() are not following standard RCU rules. [a] dst_release(dst) [b] sk->sk_rx_dst = NULL They look wrong because a delete operation of RCU protected pointer is supposed to clear the pointer before the call_rcu()/synchronize_rcu() guarding actual memory freeing. In some cases indeed, dst could be freed before [b] is done. We could cheat by clearing sk_rx_dst before calling dst_release(), but this seems the right time to stick to standard RCU annotations and debugging facilities. [1] BUG KASAN use-after-free in dst_check include/net/dst.h470 [inline] BUG KASAN use-after-free in tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c1792 Read of size 2 at addr ffff88807f1cb73a by task syz-executor.5/9204 CPU 0 PID 9204 Comm syz-executor.5 Not tainted 5.16.0-rc5-syzkaller #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace __dump_stack lib/dump_stack.c88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c106 print_address_description.constprop.0.cold+0x8d/0x320 mm/kasan/report.c247 __kasan_report mm/kasan/report.c433 [inline] kasan_report.cold+0x83/0xdf mm/kasan/re",
    "keyphrases": {
        "rootcause": "",
        "weakness": "use-after-free",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "5.16.0-rc5-syzkaller",
        "component": "tcp_v4_early_demux/tcp_v6_early_demux"
    }
}
