{
    "cveId": "CVE-2021-47038",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved Bluetooth avoid deadlock between hci_dev->lock and socket lock Commit eab2404ba798 (Bluetooth Add BT_PHY socket option) added a dependency between socket lock and hci_dev->lock that could lead to deadlock. It turns out that hci_conn_get_phy() is not in any way relying on hdev being immutable during the runtime of this function, neither does it even look at any of the members of hdev, and as such there is no need to hold that lock. This fixes the lockdep splat below ====================================================== WARNING possible circular locking dependency detected 5.12.0-rc1-00026-g73d464503354 #10 Not tainted ------------------------------------------------------ bluetoothd/1118 is trying to acquire lock ffff8f078383c078 (&hdev->lock){+.+.}-{33}, at hci_conn_get_phy+0x1c/0x150 [bluetooth] but task is already holding lock ffff8f07e831d920 (sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP){+.+.}-{00}, at l2cap_sock_getsockopt+0x8b/0x610 which lock already depends on the new lock. the existing dependency chain (in reverse order) is -> #3 (sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP){+.+.}-{00} lock_sock_nested+0x72/0xa0 l2cap_sock_ready_cb+0x18/0x70 [bluetooth] l2cap_config_rsp+0x27a/0x520 [bluetooth] l2cap_sig_channel+0x658/0x1330 [bluetooth] l2cap_recv_frame+0x1ba/0x310 [bluetooth] hci_rx_work+0x1cc/0x640 [bluetooth] process_one_work+",
    "keyphrases": {
        "rootcause": "dependency between socket lock and hci_dev->lock",
        "weakness": "",
        "impact": "deadlock",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "5.12.0-rc1-00026-g73d464503354",
        "component": "Bluetooth"
    }
}
