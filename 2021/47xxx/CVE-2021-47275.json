{
    "cveId": "CVE-2021-47275",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved bcache avoid oversized read request in cache missing code path In the cache missing code path of cached device, if a proper location from the internal B+ tree is matched for a cache miss range, function cached_dev_cache_miss() will be called in cache_lookup_fn() in the following code block, [code block 1] 526 unsigned int sectors = KEY_INODE(k) == s->iop.inode 527 ? min_t(uint64_t, INT_MAX, 528 KEY_START(k) - bio->bi_iter.bi_sector) 529 INT_MAX 530 int ret = s->d->cache_miss(b, s, bio, sectors) Here s->d->cache_miss() is the call backfunction pointer initialized as cached_dev_cache_miss(), the last parameter sectors is an important hint to calculate the size of read request to backing device of the missing cache data. Current calculation in above code block may generate oversized value of sectors, which consequently may trigger 2 different potential kernel panics by BUG() or BUG_ON() as listed below, 1) BUG_ON() inside bch_btree_insert_key(), [code block 2] 886 BUG_ON(b->ops->is_extents && !KEY_SIZE(k)) 2) BUG() inside biovec_slab(), [code block 3] 51 default 52 BUG() 53 return NULL All the above panics are original from cached_dev_cache_miss() by the oversized parameter sectors. Inside cached_dev_cache_miss(), parameter sectors is used to calcul",
    "keyphrases": {
        "rootcause": "improper calculation of read request size",
        "weakness": "",
        "impact": "kernel panic",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "bcache"
    }
}
