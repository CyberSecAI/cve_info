{
    "cveId": "CVE-2021-47185",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvedtty tty_buffer Fix the softlockup issue in flush_to_ldiscWhen running ltp testcase(ltp/testcases/kernel/pty/pty04.c) with arm64, there is a soft lockup,which look like this one Workqueue events_unbound flush_to_ldisc Call trace dump_backtrace+0x0/0x1ec show_stack+0x24/0x30 dump_stack+0xd0/0x128 panic+0x15c/0x374 watchdog_timer_fn+0x2b8/0x304 __run_hrtimer+0x88/0x2c0 __hrtimer_run_queues+0xa4/0x120 hrtimer_interrupt+0xfc/0x270 arch_timer_handler_phys+0x40/0x50 handle_percpu_devid_irq+0x94/0x220 __handle_domain_irq+0x88/0xf0 gic_handle_irq+0x84/0xfc el1_irq+0xc8/0x180 slip_unesc+0x80/0x214 [slip] tty_ldisc_receive_buf+0x64/0x80 tty_port_default_receive_buf+0x50/0x90 flush_to_ldisc+0xbc/0x110 process_one_work+0x1d4/0x4b0 worker_thread+0x180/0x430 kthread+0x11c/0x120In the testcase pty04, The first process call the write syscall to senddata to the pty master. At the same time, the workqueue will do theflush_to_ldisc to pop data in a loop until there is no more data left.When the sender and workqueue running in different core, the sender sendsdata fastly in full time which will result in workqueue doing work in loopfor a long time and occuring softlockup in flush_to_ldisc with kernelconfigured without preempt. So I add need_resched check and cond_reschedin the flush_to_ldisc loop to avoid it.",
    "keyphrases": {
        "rootcause": "The workqueue continuously processes data in a loop within the flush_to_ldisc function, leading to a soft lockup when the sender sends data rapidly and the kernel is configured without preemption.",
        "weakness": "Lack of scheduling checks within the flush_to_ldisc loop, allowing it to monopolize the CPU when handling a high volume of data.",
        "impact": "Soft lockup in the kernel, potentially leading to system instability or unresponsiveness.",
        "vector": "The vulnerability is triggered by writing data to a pty master, which causes the workqueue to process the data in the tty subsystem. When the sender and the workqueue are running on different cores and the sender is sending data rapidly, it triggers the bug.",
        "attacker": "A local user that can write data to a pty.",
        "product": "Linux Kernel",
        "version": "Not specified but before the patch that introduces need_resched check and cond_resched in flush_to_ldisc loop",
        "component": "tty"
    }
}
