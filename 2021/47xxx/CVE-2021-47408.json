{
    "cveId": "CVE-2021-47408",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvednetfilter conntrack serialize hash resizes and cleanupsSyzbot was able to trigger the following warning [1]No repro found by syzbot yet but I was able to trigger similar issueby having 2 scripts running in parallel, changing conntrack hash sizes,andfor j in `seq 1 1000` do unshare -n /bin/true >/dev/null doneIt would take more than 5 minutes for net_namespace structuresto be cleaned up.This is because nf_ct_iterate_cleanup() has to restart everytimea resize happened.By adding a mutex, we can serialize hash resizes and cleanupsand also make get_next_corpse() faster by skipping over emptybuckets.Even without resizes in the picture, this patch considerablyspeeds up network namespace dismantles.[1]INFO task syz-executor.08312 cant die for more than 144 seconds.tasksyz-executor.0 stateR running task stack25672 pid 8312 ppid 6573 flags0x00004006Call Trace context_switch kernel/sched/core.c4955 [inline] __schedule+0x940/0x26f0 kernel/sched/core.c6236 preempt_schedule_common+0x45/0xc0 kernel/sched/core.c6408 preempt_schedule_thunk+0x16/0x18 arch/x86/entry/thunk_64.S35 __local_bh_enable_ip+0x109/0x120 kernel/softirq.c390 local_bh_enable include/linux/bottom_half.h32 [inline] get_next_corpse net/netfilter/nf_conntrack_core.c2252 [inline] nf_ct_iterate_cleanup+0x15a/0x450 net/netfilter/nf_conntrack_core.c2275 nf_conntrack_cleanup_net_list+0x14c/0x4f0 net/netfilter/nf_conntrack_core.c2469 ops_exit_list+0x10d/0x160 net/core/net_namespace.c171 setup_net+0x639/0xa30 net/core/net_namespace.c349 copy_net_ns+0x319/0x760 net/core/net_namespace.c470 create_new_namespaces+0x3f6/0xb20 kernel/nsproxy.c110 unshare_nsproxy_namespaces+0xc1/0x1f0 kernel/nsproxy.c226 ksys_unshare+0x445/0x920 kernel/fork.c3128 __do_sys_unshare kernel/fork.c3202 [inline] __se_sys_unshare kernel/fork.c3200 [inline] __x64_sys_unshare+0x2d/0x40 kernel/fork.c3200 do_syscall_x64 arch/x86/entry/common.c50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c80 entry_SYSCALL_64_after_hwframe+0x44/0xaeRIP 00330x7f63da68e739RSP 002b00007f63d7c05188 EFLAGS 00000246 ORIG_RAX 0000000000000110RAX ffffffffffffffda RBX 00007f63da792f80 RCX 00007f63da68e739RDX 0000000000000000 RSI 0000000000000000 RDI 0000000040000000RBP 00007f63da6e8cc4 R08 0000000000000000 R09 0000000000000000R10 0000000000000000 R11 0000000000000246 R12 00007f63da792f80R13 00007fff50b75d3f R14 00007f63d7c05300 R15 0000000000022000Showing all locks held in the system1 lock held by khungtaskd/27 #0 ffffffff8b980020 (rcu_read_lock){....}-{12}, at debug_show_all_locks+0x53/0x260 kernel/locking/lockdep.c64462 locks held by kworker/u42/153 #0 ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{00}, at arch_atomic64_set arch/x86/include/asm/atomic64_64.h34 [inline] #0 ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{00}, at arch_atomic_long_set include/linux/atomic/atomic-long.h41 [inline] #0 ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{00}, at atomic_long_set include/linux/atomic/atomic-instrumented.h1198 [inline] #0 ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{00}, at set_work_data kernel/workqueue.c634 [inline] #0 ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{00}, at set_work_pool_and_clear_pending kernel/workqueue.c661 [inline] #0 ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{00}, at process_one_work+0x896/0x1690 kernel/workqueue.c2268 #1 ffffc9000140fdb0 ((kfence_timer).work){+.+.}-{00}, at process_one_work+0x8ca/0x1690 kernel/workqueue.c22721 lock held by systemd-udevd/29701 lock held by inimklog/6258 #0 ffff88807f970ff0 (&f->f_pos_lock){+.+.}-{33}, at __fdget_pos+0xe9/0x100 fs/file.c9903 locks held by kworker/16/81581 lock held by syz-executor.0/83122 locks held by kworker/u413/93201 lock held by---truncated---",
    "keyphrases": {
        "rootcause": "The netfilter conntrack module does not serialize hash resizes and cleanups, leading to a race condition where `nf_ct_iterate_cleanup()` restarts every time a resize happens. This causes delays in network namespace cleanup.",
        "weakness": "Lack of proper synchronization between hash resizes and cleanup operations in the netfilter conntrack module.",
        "impact": "Delays in network namespace dismantles and potential denial of service due to long-running cleanup operations, as evidenced by the 'task cant die' warning",
        "vector": "Exploiting the race condition by rapidly resizing the conntrack hash while simultaneously triggering cleanup operations through network namespace creation and removal.",
        "attacker": "An attacker with the ability to create and destroy network namespaces (e.g., through unshare syscalls) could trigger this vulnerability.",
        "product": "Linux Kernel",
        "version": "Likely an affected version before the fix was applied",
        "component": "netfilter conntrack module"
    }
}
