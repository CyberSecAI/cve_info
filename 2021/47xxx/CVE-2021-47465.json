{
    "cveId": "CVE-2021-47465",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved KVM PPC Book3S HV Fix stack handling in idle_kvm_start_guest() In commit 10d91611f426 (powerpc/64s Reimplement book3s idle code in C) kvm_start_guest() became idle_kvm_start_guest(). The old code allocated a stack frame on the emergency stack, but didnt use the frame to store anything, and also didnt store anything in its callers frame. idle_kvm_start_guest() on the other hand is written more like a normal C function, it creates a frame on entry, and also stores CR/LR into its callers frame (per the ABI). The problem is that there is no caller frame on the emergency stack. The emergency stack for a given CPU is allocated with paca_ptrs[i]->emergency_sp = alloc_stack(limit, i) + THREAD_SIZE So emergency_sp actually points to the first address above the emergency stack allocation for a given CPU, we must not store above it without first decrementing it to create a frame. This is different to the regular kernel stack, paca->kstack, which is initialised to point at an initial frame that is ready to use. idle_kvm_start_guest() stores the backchain, CR and LR all of which write outside the allocation for the emergency stack. It then creates a stack frame and saves the non-volatile registers. Unfortunately the frame it creates is not large enough to fit the non-volatiles, and so the saving of the non-volatile registers also writes outside the emergency stack allocation. The end result is that we",
    "keyphrases": {
        "rootcause": "",
        "weakness": "stack-based buffer overflow",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "KVM PPC Book3S HV Fix"
    }
}
