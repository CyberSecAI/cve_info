{
    "cveId": "CVE-2021-46929",
    "version": "1.0.0",
    "timestamp": "2024-12-17T08:36:27.567979+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvedsctp use call_rcu to free endpointThis patch is to delay the endpoint free by calling call_rcu() to fixanother use-after-free issue in sctp_sock_dump() BUG KASAN use-after-free in __lock_acquire+0x36d9/0x4c20 Call Trace __lock_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c3218 lock_acquire+0x1ed/0x520 kernel/locking/lockdep.c3844 __raw_spin_lock_bh include/linux/spinlock_api_smp.h135 [inline] _raw_spin_lock_bh+0x31/0x40 kernel/locking/spinlock.c168 spin_lock_bh include/linux/spinlock.h334 [inline] __lock_sock+0x203/0x350 net/core/sock.c2253 lock_sock_nested+0xfe/0x120 net/core/sock.c2774 lock_sock include/net/sock.h1492 [inline] sctp_sock_dump+0x122/0xb20 net/sctp/diag.c324 sctp_for_each_transport+0x2b5/0x370 net/sctp/socket.c5091 sctp_diag_dump+0x3ac/0x660 net/sctp/diag.c527 __inet_diag_dump+0xa8/0x140 net/ipv4/inet_diag.c1049 inet_diag_dump+0x9b/0x110 net/ipv4/inet_diag.c1065 netlink_dump+0x606/0x1080 net/netlink/af_netlink.c2244 __netlink_dump_start+0x59a/0x7c0 net/netlink/af_netlink.c2352 netlink_dump_start include/linux/netlink.h216 [inline] inet_diag_handler_cmd+0x2ce/0x3f0 net/ipv4/inet_diag.c1170 __sock_diag_cmd net/core/sock_diag.c232 [inline] sock_diag_rcv_msg+0x31d/0x410 net/core/sock_diag.c263 netlink_rcv_skb+0x172/0x440 net/netlink/af_netlink.c2477 sock_diag_rcv+0x2a/0x40 net/core/sock_diag.c274This issue occurs when asoc is peeled off and the old sk is freed aftergetting it by asoc->base.sk and before calling lock_sock(sk).To prevent the sk free, as a holder of the sk, ep should be alive whencalling lock_sock(). This patch uses call_rcu() and moves sock_put andep free into sctp_endpoint_destroy_rcu(), so that its safe to try tohold the ep under rcu_read_lock in sctp_transport_traverse_process().If sctp_endpoint_hold() returns true, it means this ep is still aliveand we have held it and can continue to dump it If it returns false,it means this ep is dead and can be freed after rcu_read_unlock, andwe should skip it.In sctp_sock_dump(), after locking the sk, if this ep is different fromtsp->asoc->ep, it means during this dumping, this asoc was peeled offbefore calling lock_sock(), and the sk should be skipped If this ep isthe same with tsp->asoc->ep, it means no peeloff happens on this asoc,and due to lock_sock, no peeloff will happen either until release_sock.Note that delaying endpoint free wont delay the port release, as theport release happens in sctp_endpoint_destroy() before calling call_rcu().Also, freeing endpoint by call_rcu() makes it safe to access the sk byasoc->base.sk in sctp_assocs_seq_show() and sctp_rcv().Thanks Jones to bring this issue up.v1->v2 - improve the changelog. - add kfree(ep) into sctp_endpoint_destroy_rcu(), as Jakub noticed.",
    "keyphrases": {
        "rootcause": "",
        "weakness": "use-after-free",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "sctp"
    }
}
