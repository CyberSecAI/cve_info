{
    "cveId": "CVE-2021-46978",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved KVM nVMX Always make an attempt to map eVMCS after migration When enlightened VMCS is in use and nested state is migrated with vmx_get_nested_state()/vmx_set_nested_state() KVM cant map evmcs page right away evmcs gpa is not struct kvm_vmx_nested_state_hdr and we cant read it from VP assist page because userspace may decide to restore HV_X64_MSR_VP_ASSIST_PAGE after restoring nested state (and QEMU, for example, does exactly that). To make sure eVMCS is mapped /vmx_set_nested_state() raises KVM_REQ_GET_NESTED_STATE_PAGES request. Commit f2c7ef3ba955 (KVM nSVM cancel KVM_REQ_GET_NESTED_STATE_PAGES on nested vmexit) added KVM_REQ_GET_NESTED_STATE_PAGES clearing to nested_vmx_vmexit() to make sure MSR permission bitmap is not switched when an immediate exit from L2 to L1 happens right after migration (caused by a pending event, for example). Unfortunately, in the exact same situation we still need to have eVMCS mapped so nested_sync_vmcs12_to_shadow() reflects changes in VMCS12 to eVMCS. As a band-aid, restore nested_get_evmcs_page() when clearing KVM_REQ_GET_NESTED_STATE_PAGES in nested_vmx_vmexit(). The fix is far from being ideal as we cant easily propagate possible failures and even if we could, this is most likely already too late to do so. The whole KVM_REQ_GET_NESTED_STATE_PAGES idea for mapping eVMCS after migration seems to be fragile as we diverge too much from the native path whe",
    "keyphrases": {
        "rootcause": "KVM nVMX Always make an attempt to map eVMCS after migration When enlightened VMCS is in use and nested state is migrated with vmx_get_nested_state()/vmx_set_nested_state() KVM cant map evmcs page right away evmcs gpa is not struct kvm_vmx_nested_state_hdr and we cant read it from VP assist page because userspace may decide to restore HV_X64_MSR_VP_ASSIST_PAGE after restoring nested state (and QEMU, for example, does exactly that).",
        "weakness": "",
        "impact": "improper mapping of eVMCS page",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "KVM nVMX"
    }
}
