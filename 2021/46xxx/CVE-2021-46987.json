{
    "cveId": "CVE-2021-46987",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs fix deadlock when cloning inline extents and using qgroups There are a few exceptional cases where cloning an inline extent needs to copy the inline extent data into a page of the destination inode. When this happens, we end up starting a transaction while having a dirty page for the destination inode and while having the range locked in the destinations inode iotree too. Because when reserving metadata space for a transaction we may need to flush existing delalloc in case there is not enough free space, we have a mechanism in place to prevent a deadlock, which was introduced in commit 3d45f221ce627d (btrfs fix deadlock when cloning inline extent and low on free metadata space). However when using qgroups, a transaction also reserves metadata qgroup space, which can also result in flushing delalloc in case there is not enough available space at the moment. When this happens we deadlock, since flushing delalloc requires locking the file range in the inodes iotree and the range was already locked at the very beginning of the clone operation, before attempting to start the transaction. When this issue happens, stack traces like the following are reported [72747.556262] taskkworker/u819 stateD stack 0 pid 225 ppid 2 flags0x00004000 [72747.556268] Workqueue writeback wb_workfn (flush-btrfs-1142) [72747.556271] Call Trace [72747.556273] __schedule+0x296/0x760 [72747.",
    "keyphrases": {
        "rootcause": "deadlock when cloning inline extents and using qgroups",
        "weakness": "",
        "impact": "deadlock",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs"
    }
}
