{
  "cveId": "CVE-2021-46989",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved hfsplus prevent corruption in shrinking truncate I believe there are some issues introduced by commit 31651c607151 (hfsplus avoid deadlock on file truncation) HFS+ has extent records which always contains 8 extents. In case the first extent record in catalog file gets full, new ones are allocated from extents overflow file. In case shrinking truncate happens to middle of an extent record which locates in extents overflow file, the logic in hfsplus_file_truncate() was changed so that call to hfs_brec_remove() is not guarded any more. Right action would be just freeing the extents that exceed the new size inside extent record by calling hfsplus_free_extents(), and then check if the whole extent record should be removed. However since the guard (blk_cnt > start) is now after the call to hfs_brec_remove(), this has unfortunate effect that the last matching extent record is removed unconditionally. To reproduce this issue, create a file which has at least 10 extents, and then perform shrinking truncate into middle of the last extent record, so that the number of remaining extents is not under or divisible by 8. This causes the last extent record (8 extents) to be removed totally instead of truncating into middle of it. Thus this causes corruption, and lost data. Fix for this is simply checking if the new truncated end is below the start of this extent record, making it safe to remove the full extent",
  "keyphrases": {
    "rootcause": "improper guard condition",
    "weakness": "overflow",
    "impact": "data corruption",
    "vector": "shrinking truncate of file with at least 10 extents",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "hfsplus"
  },
  "mitreTechnicalImpacts": []
}