{
  "cveId": "CVE-2024-42266",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved btrfs make cow_file_range_inline() honor locked_page on error The btrfs buffered write path runs through __extent_writepage() which has some tricky return value handling for writepage_delalloc(). Specifically, when that returns 1, we exit, but for other return values we continue and end up calling btrfs_folio_end_all_writers(). If the folio has been unlocked (note that we check the PageLocked bit at the start of __extent_writepage()), this results in an assert panic like this one from syzbot BTRFS error (device loop0 state EAL) in free_log_tree3267 errno=-5 IO failure BTRFS warning (device loop0 state EAL) Skipping commit of aborted transaction. BTRFS error (device loop0 state EAL) in cleanup_transaction2018 errno=-5 IO failure assertion failed folio_test_locked(folio), in fs/btrfs/subpage.c871 ------------[ cut here ]------------ kernel BUG at fs/btrfs/subpage.c871! Oops invalid opcode 0000 [#1] PREEMPT SMP KASAN PTI CPU 1 PID 5090 Comm syz-executor225 Not tainted 6.10.0-syzkaller-05505-gb1bc554e009e #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024 RIP 0010btrfs_folio_end_all_writers+0x55b/0x610 fs/btrfs/subpage.c871 Code e9 d3 fb ff ff e8 25 22 c2 fd 48 c7 c7 c0 3c 0e 8c 48 c7 c6 80 3d 0e 8c 48 c7 c2 60 3c 0e 8c b9 67 03 00 00 e8 66 47 ad 07 90 0b e8 6e 45 b0 07 4c 89 ff be 08 00 00 00 e8 21 12 25 fe 4c 89",
  "keyphrases": {
    "rootcause": "If the folio has been unlocked ...",
    "weakness": "",
    "impact": [
      "Oops",
      "assert panic",
      "kernel BUG"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "btrfs"
  },
  "mitreTechnicalImpacts": []
}