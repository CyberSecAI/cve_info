{
    "cveId": "CVE-2024-46787",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved userfaultfd fix checks for huge PMDs Patch series userfaultfd fix races around pmd_trans_huge() check, v2. The pmd_trans_huge() code in mfill_atomic() is wrong in three different ways depending on kernel version 1. The pmd_trans_huge() check is racy and can lead to a BUG_ON() (if you hit the right two race windows) - Ive tested this in a kernel build with some extra mdelay() calls. See the commit message for a description of the race scenario. On older kernels (before 6.5), I think the same bug can even theoretically lead to accessing transhuge page contents as a page table if you hit the right 5 narrow race windows (I havent tested this case). 2. As pointed out by Qi Zheng, pmd_trans_huge() is not sufficient for detecting PMDs that dont point to page tables. On older kernels (before 6.5), youd just have to win a single fairly wide race to hit this. Ive tested this on 6.1 stable by racing migration (with a mdelay() patched into try_to_migrate()) against UFFDIO_ZEROPAGE - on my x86 VM, that causes a kernel oops in ptlock_ptr(). 3. On newer kernels (>=6.5), for shmem mappings, khugepaged is allowed to yank page tables out from under us (though I havent tested that), so I think the BUG_ON() checks in mfill_atomic() are just wrong. I decided to write two separate fixes for these (one fix for bugs 1+2, one fix for bug 3), so that the first fix can be backpo",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "kernel oops in ptlock_ptr()",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.1",
        "component": "userfaultfd"
    }
}
