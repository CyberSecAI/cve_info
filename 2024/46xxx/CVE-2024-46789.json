{
    "cveId": "CVE-2024-46789",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mm/slub add check for s->flags in the alloc_tagging_slab_free_hook When enable CONFIG_MEMCG & CONFIG_KFENCE & CONFIG_KMEMLEAK, the following warning always occurs,This is because the following call stack occurred mem_pool_alloc kmem_cache_alloc_noprof slab_alloc_node kfence_alloc Once the kfence allocation is successful,slab->obj_exts will not be empty, because it has already been assigned a value in kfence_init_pool. Since in the prepare_slab_obj_exts_hook function,we perform a check for s->flags & (SLAB_NO_OBJ_EXT | SLAB_NOLEAKTRACE),the alloc_tag_add function will not be called as a result.Therefore,ref->ct remains NULL. However,when we call mem_pool_free,since obj_ext is not empty, it eventually leads to the alloc_tag_sub scenario being invoked. This is where the warning occurs. So we should add corresponding checks in the alloc_tagging_slab_free_hook. For __GFP_NO_OBJ_EXT case,I didnt see the specific case where its using kfence,so I wont add the corresponding check in alloc_tagging_slab_free_hook for now. [ 3.734349] ------------[ cut here ]------------ [ 3.734807] alloc_tag was not set [ 3.735129] WARNING CPU 4 PID 40 at ./include/linux/alloc_tag.h130 kmem_cache_free+0x444/0x574 [ 3.735866] Modules linked in autofs4 [ 3.736211] CPU 4 UID 0 PID 40 Comm ksoftirqd/4 Tainted G W 6.11.0-rc3-dirty #1 [ 3.736969] Tainted [W]=WAR",
    "keyphrases": {
        "rootcause": "improper slab allocation and deallocation",
        "weakness": "",
        "impact": "use-after-free",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.11.0-rc3-dirty",
        "component": "mem_pool_alloc"
    }
}
