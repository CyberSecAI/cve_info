{
    "cveId": "CVE-2024-46734",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs fix race between direct IO write and fsync when using same fd If we have 2 threads that are using the same file descriptor and one of them is doing direct IO writes while the other is doing fsync, we have a race where we can end up either 1) Attempt a fsync without holding the inodes lock, triggering an assertion failures when assertions are enabled 2) Do an invalid memory access from the fsync task because the file private points to memory allocated on stack by the direct IO task and it may be used by the fsync task after the stack was destroyed. The race happens like this 1) A user space program opens a file descriptor with O_DIRECT 2) The program spawns 2 threads using libpthread for example 3) One of the threads uses the file descriptor to do direct IO writes, while the other calls fsync using the same file descriptor. 4) Call task A the thread doing direct IO writes and task B the thread doing fsyncs 5) Task A does a direct IO write, and at btrfs_direct_write() sets the files private to an on stack allocated private with the member fsync_skip_inode_lock set to true 6) Task B enters btrfs_sync_file() and sees that theres a private structure associated to the file which has fsync_skip_inode_lock set to true, so it skips locking the inodes VFS lock 7) Task A completes the direct IO write, and resets the files private to NULL since it had no p",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "assertion failures, invalid memory access",
        "vector": "direct IO write and fsync using same fd",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs"
    }
}
