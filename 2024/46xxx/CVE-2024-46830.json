{
    "cveId": "CVE-2024-46830",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved KVM x86 Acquire kvm->srcu when handling KVM_SET_VCPU_EVENTS Grab kvm->srcu when processing KVM_SET_VCPU_EVENTS, as KVM will forcibly leave nested VMX/SVM if SMM mode is being toggled, and leaving nested VMX reads guest memory. Note, kvm_vcpu_ioctl_x86_set_vcpu_events() can also be called from KVM_RUN via sync_regs(), which already holds SRCU. I.e. trying to precisely use kvm_vcpu_srcu_read_lock() around the problematic SMM code would cause problems. Acquiring SRCU isnt all that expensive, so for simplicity, grab it unconditionally for KVM_SET_VCPU_EVENTS. ============================= WARNING suspicious RCU usage 6.10.0-rc7-332d2c1d713e-next-vm #552 Not tainted ----------------------------- include/linux/kvm_host.h1027 suspicious rcu_dereference_check() usage! other info that might help us debug this rcu_scheduler_active = 2, debug_locks = 1 1 lock held by repro/1071 #0 ffff88811e424430 (&vcpu->mutex){+.+.}-{33}, at kvm_vcpu_ioctl+0x7d/0x970 [kvm] stack backtrace CPU 15 PID 1071 Comm repro Not tainted 6.10.0-rc7-332d2c1d713e-next-vm #552 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 Call Trace dump_stack_lvl+0x7f/0x90 lockdep_rcu_suspicious+0x13f/0x1a0 kvm_vcpu_gfn_to_memslot+0x168/0x190 [kvm] kvm_vcpu_read_guest+0x3e/0x90 [kvm] nested_vmx_load_msr+0x6b/0x1d0 [kvm_intel] load_vmcs12_host_state+0x432/0xb40 [kvm_intel] vmx_",
    "keyphrases": {
        "rootcause": "suspicious RCU usage",
        "weakness": "",
        "impact": "read guest memory",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.10.0-rc7-332d2c1d713e-next-vm#552",
        "component": "KVM x86"
    }
}
