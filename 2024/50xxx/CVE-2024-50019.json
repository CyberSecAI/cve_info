{
    "cveId": "CVE-2024-50019",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved kthread unpark only parked kthread Calling into kthread unparking unconditionally is mostly harmless when the kthread is already unparked. The wake up is then simply ignored because the target is not in TASK_PARKED state. However if the kthread is per CPU, the wake up is preceded by a call to kthread_bind() which expects the task to be inactive and in TASK_PARKED state, which obviously isnt the case if it is unparked. As a result, calling kthread_stop() on an unparked per-cpu kthread triggers such a warning WARNING CPU 0 PID 11 at kernel/kthread.c525 __kthread_bind_mask kernel/kthread.c525 kthread_stop+0x17a/0x630 kernel/kthread.c707 destroy_workqueue+0x136/0xc40 kernel/workqueue.c5810 wg_destruct+0x1e2/0x2e0 drivers/net/wireguard/device.c257 netdev_run_todo+0xe1a/0x1000 net/core/dev.c10693 default_device_exit_batch+0xa14/0xa90 net/core/dev.c11769 ops_exit_list net/core/net_namespace.c178 [inline] cleanup_net+0x89d/0xcc0 net/core/net_namespace.c640 process_one_work kernel/workqueue.c3231 [inline] process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c3312 worker_thread+0x86d/0xd70 kernel/workqueue.c3393 kthread+0x2f0/0x390 kernel/kthread.c389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S244 Fix this with skipping unecessary unparking while stopping a kthread.",
    "keyphrases": {
        "rootcause": "",
        "weakness": "race condition",
        "impact": "information disclosure",
        "vector": "triggering a spurious warning",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "kthread_stop() on an unparked per-cpu kthread"
    }
}
