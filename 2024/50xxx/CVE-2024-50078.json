{
  "cveId": "CVE-2024-50078",
  "version": "1.0.0",
  "timestamp": "2024-12-17T08:36:27.567979+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved Bluetooth Call iso_exit() on module unload If iso_init() has been called, iso_exit() must be called on module unload. Without that, the struct proto that iso_init() registered with proto_register() becomes invalid, which could cause unpredictable problems later. In my case, with CONFIG_LIST_HARDENED and CONFIG_BUG_ON_DATA_CORRUPTION enabled, loading the module again usually triggers this BUG() list_add corruption. next->prev should be prev (ffffffffb5355fd0), but was 0000000000000068. (next=ffffffffc0a010d0). ------------[ cut here ]------------ kernel BUG at lib/list_debug.c29! Oops invalid opcode 0000",
  "keyphrases": {
    "rootcause": [
      "iso_exit() on module unload If iso_init() has been called",
      "iso_exit() must be called on module unload. Without that",
      "the struct proto that iso_init() registered with proto_register() becomes invalid"
    ],
    "weakness": "improper memory management",
    "impact": [
      "BUG() list_add corruption",
      "Oops",
      "kernel BUG"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "Bluetooth Call"
  },
  "mitreTechnicalImpacts": []
}