{
  "cveId": "CVE-2024-56566",
  "version": "1.0.0",
  "timestamp": "2025-07-04T16:12:41.853043+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved mm/slub Avoid list corruption when removing a slab from the full list Boot with slub_debug=UFPZ. If allocated object failed in alloc_consistency_checks, all objects of the slab will be marked as used, and then the slab will be removed from the partial list. When an object belonging to the slab got freed later, the remove_full() function is called. Because the slab is neither on the partial list nor on the full list, it eventually lead to a list corruption (actually a list poison being detected). So we need to mark and isolate the slab page with metadata corruption, do not put it back in circulation. Because the debug caches avoid all the fastpaths, reusing the frozen bit to mark slab page with metadata corruption seems to be fine. [ 4277.385669] list_del corruption, ffffea00044b3e50->next is LIST_POISON1 (dead000000000100) [ 4277.387023] ------------[ cut here ]------------ [ 4277.387880] kernel BUG at lib/list_debug.c56! [ 4277.388680] invalid opcode 0000",
  "keyphrases": {
    "rootcause": "",
    "weakness": "list corruption",
    "impact": "kernel BUG",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "mm/slub"
  },
  "mitreTechnicalImpacts": []
}