{
    "cveId": "CVE-2024-56714",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved ionic no double destroy workqueue There are some FW error handling paths that can cause us to try to destroy the workqueue more than once, so lets be sure were checking for that. The case where this popped up was in an AER event where the handlers got called in such a way that ionic_reset_prepare() and thus ionic_dev_teardown() got called twice in a row. The second time through the workqueue was already destroyed, and destroy_workqueue() choked on the bad wq pointer. We didnt hit this in AER handler testing before because at that time we werent using a private workqueue. Later we replaced the use of the system workqueue with our own private workqueue but hadnt rerun the AER handler testing since then.",
    "keyphrases": {
        "rootcause": "ionic_reset_prepare() and ionic_dev_teardown() called twice in a row",
        "weakness": "",
        "impact": "destroy_workqueue() choked on the bad wq pointer",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "ionc_no_double_destroy_workqueue"
    }
}
