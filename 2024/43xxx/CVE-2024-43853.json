{
    "cveId": "CVE-2024-43853",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved cgroup/cpuset Prevent UAF in proc_cpuset_show() An UAF can happen when /proc/cpuset is read as reported in [1]. This can be reproduced by the following methods 1.add an mdelay(1000) before acquiring the cgroup_lock In the cgroup_path_ns function. 2.$cat /proc//cpuset repeatly. 3.$mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset/ $umount /sys/fs/cgroup/cpuset/ repeatly. The race that cause this bug can be shown as below (umount)|(cat /proc//cpuset) css_release|proc_cpuset_show css_release_work_fn|css = task_get_css(tsk, cpuset_cgrp_id) css_free_rwork_fn|cgroup_path_ns(css->cgroup, ...) cgroup_destroy_root|mutex_lock(&cgroup_mutex) rebind_subsystems| cgroup_free_root | |// cgrp was freed, UAF |cgroup_path_ns_locked(cgrp,..) When the cpuset is initialized, the root node top_cpuset.css.cgrp will point to &cgrp_dfl_root.cgrp. In cgroup v1, the mount operation will allocate cgroup_root, and top_cpuset.css.cgrp will point to the allocated &cgroup_root.cgrp. When the umount operation is executed, top_cpuset.css.cgrp will be rebound to &cgrp_dfl_root.cgrp. The problem is that when rebinding to cgrp_dfl_root, there are cases where the cgroup_root allocated by setting up the root for cgroup v1 is cached. This could lead to a Use-After-Free (UAF) if it is subsequently freed. The descendant cgroups of cgroup v1 can only be freed after the css is released. However, the css of the root wil",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "Use-After-Free",
        "impact": "",
        "vector": "read /proc/cpuset",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "cgroup/cpuset"
    }
}
