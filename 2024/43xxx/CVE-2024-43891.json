{
    "cveId": "CVE-2024-43891",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved tracing Have format file honor EVENT_FILE_FL_FREED When eventfs was introduced, special care had to be done to coordinate the freeing of the file meta data with the files that are exposed to user space. The file meta data would have a ref count that is set when the file is created and would be decremented and freed after the last user that opened the file closed it. When the file meta data was to be freed, it would set a flag (EVENT_FILE_FL_FREED) to denote that the file is freed, and any new references made (like new opens or reads) would fail as it is marked freed. This allowed other meta data to be freed after this flag was set (under the event_mutex). All the files that were dynamically created in the events directory had a pointer to the file meta data and would call event_release() when the last reference to the user space file was closed. This would be the time that it is safe to free the file meta data. A shortcut was made for the format file. Its i_private would point to the call entry directly and not point to the files meta data. This is because all format files are the same for the same call, so it was thought there was no reason to differentiate them. The other files maintain state (like the enable, trigger, etc). But this meant if the file were to disappear, the format file would be unaware of it. This caused a race that could be trigger via the user_events test (that would",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "use-after-free",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "eventfs"
    }
}
