{
    "cveId": "CVE-2024-43806",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "Rustix is a set of safe Rust bindings to POSIX-ish APIs. When using `rustixfsDir` using the `linux_raw` backend, its possible for the iterator to get stuck when an IO error is encountered. Combined with a memory over-allocation issue in `rustixfsDirread_more`, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application. The symptoms were initially discovered in https//github.com/imsnif/bandwhich/issues/284. That post has lots of details of our investigation. Full details can be read on the GHSA-c827-hfw6-qwvm repo advisory. If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the `Dir` iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion. As an example, Linuxs various virtual file systems (e.g. `/proc`, `/sys`) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using `rustixfsDir` directly or indirectly (e.g. with the `procfs` crate) can trigger this fault condition if the implementation decides to continue on errors. An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of m",
    "keyphrases": {
        "rootcause": "memory over-allocation",
        "weakness": "",
        "impact": [
            "memory explosion",
            "OOM crash"
        ],
        "vector": "",
        "attacker": "",
        "product": "Rustix",
        "version": "",
        "component": "rustixfsDir"
    }
}
