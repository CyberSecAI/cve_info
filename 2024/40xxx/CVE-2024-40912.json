{
    "cveId": "CVE-2024-40912",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved wifi mac80211 Fix deadlock in ieee80211_sta_ps_deliver_wakeup() The ieee80211_sta_ps_deliver_wakeup() function takes sta->ps_lock to synchronizes with ieee80211_tx_h_unicast_ps_buf() which is called from softirq context. However using only spin_lock() to get sta->ps_lock in ieee80211_sta_ps_deliver_wakeup() does not prevent softirq to execute on this same CPU, to run ieee80211_tx_h_unicast_ps_buf() and try to take this same lock ending in deadlock. Below is an example of rcu stall that arises in such situation. rcu INFO rcu_sched self-detected stall on CPU rcu 2-.... (42413413 ticks this GP) idle=b154/1/0x4000000000000000 softirq=1763/1765 fqs=21206996 rcu (t=42586894 jiffies g=2057 q=362405 ncpus=4) CPU 2 PID 719 Comm wpa_supplicant Tainted G W 6.4.0-02158-g1b062f552873 #742 Hardware name RPT (r1) (DT) pstate 00000005 (nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc queued_spin_lock_slowpath+0x58/0x2d0 lr invoke_tx_handlers_early+0x5b4/0x5c0 sp ffff00001ef64660 x29 ffff00001ef64660 x28 ffff000009bc1070 x27 ffff000009bc0ad8 x26 ffff000009bc0900 x25 ffff00001ef647a8 x24 0000000000000000 x23 ffff000009bc0900 x22 ffff000009bc0900 x21 ffff00000ac0e000 x20 ffff00000a279e00 x19 ffff00001ef646e8 x18 0000000000000000 x17 ffff800016468000 x16 ffff00001ef608c0 x15 0010533c93f64f80 x14 0010395c9faa3946 x13 0000000000000000 x12 00000000fa83b2da"
}
