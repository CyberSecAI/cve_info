{
    "cveId": "CVE-2024-40925",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved block fix request.queuelist usage in flush Friedrich Weber reported a kernel crash problem and bisected to commit 81ada09cc25e (blk-flush reuse rq queuelist in flush state machine). The root cause is that we use list_move_tail(&rq->queuelist, pending) in the PREFLUSH/POSTFLUSH sequences. But rq->queuelist.next == xxx since its popped out from plug->cached_rq in __blk_mq_alloc_requests_batch(). We dont initialize its queuelist just for this first request, although the queuelist of all later popped requests will be initialized. Fix it by changing to use list_add_tail(&rq->queuelist, pending) so rq->queuelist doesnt need to be initialized. It should be ok since rq cant be on any list when PREFLUSH or POSTFLUSH, has no move actually. Please note the commit 81ada09cc25e (blk-flush reuse rq queuelist in flush state machine) also has another requirement that no drivers would touch rq->queuelist after blk_mq_end_request() since we will reuse it to add rq to the post-flush pending list in POSTFLUSH. If this is not true, we will have to revert that commit IMHO. This updated version adds list_del_init(&rq->queuelist) in flush rq callback since the dm layer may submit request of a weird invalid format (REQ_FSEQ_PREFLUSH | REQ_FSEQ_POSTFLUSH), which causes double list_add if without this list_del_init(&rq->queuelist). The weird invalid format problem should be fixed in dm layer.",
    "keyphrases": {
        "rootcause": "use of list_move_tail in PREFLUSH/POSTFLUSH",
        "weakness": "",
        "impact": "kernel crash",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "block fix request.queuelist usage in flush"
    }
}
