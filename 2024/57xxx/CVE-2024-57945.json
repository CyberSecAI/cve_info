{
    "cveId": "CVE-2024-57945",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved riscv mm Fix the out of bound issue of vmemmap address In sparse vmemmap model, the virtual address of vmemmap is calculated as ((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT)). And the struct pages va can be calculated with an offset (vmemmap + (pfn)). However, when initializing struct pages, kernel actually starts from the first page from the same section that phys_ram_base belongs to. If the first pages physical address is not (phys_ram_base >> PAGE_SHIFT), then we get an va below VMEMMAP_START when calculating va for its struct page. For example, if phys_ram_base starts from 0x82000000 with pfn 0x82000, the first page in the same section is actually pfn 0x80000. During init_unavailable_range(), we will initialize struct page for pfn 0x80000 with virtual address ((struct page *)VMEMMAP_START - 0x2000), which is below VMEMMAP_START as well as PCI_IO_END. This commit fixes this bug by introducing a new variable vmemmap_start_pfn which is aligned with memory section size and using it to calculate vmemmap address instead of phys_ram_base.",
    "keyphrases": {
        "rootcause": "",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "riscv mm"
    }
}
