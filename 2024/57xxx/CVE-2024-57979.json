{
    "cveId": "CVE-2024-57979",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved pps Fix a use-after-free On a board running ntpd and gpsd, Im seeing a consistent use-after-free in sys_exit() from gpsd when rebooting pps pps1 removed ------------[ cut here ]------------ kobject (null) (00000000db4bec24) is not initialized, yet kobject_put() is being called. WARNING CPU 2 PID 440 at lib/kobject.c734 kobject_put+0x120/0x150 CPU 2 UID 299 PID 440 Comm gpsd Not tainted 6.11.0-rc6-00308-gb31c44928842 #1 Hardware name Raspberry Pi 4 Model B Rev 1.1 (DT) pstate 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc kobject_put+0x120/0x150 lr kobject_put+0x120/0x150 sp ffffffc0803d3ae0 x29 ffffffc0803d3ae0 x28 ffffff8042dc9738 x27 0000000000000001 x26 0000000000000000 x25 ffffff8042dc9040 x24 ffffff8042dc9440 x23 ffffff80402a4620 x22 ffffff8042ef4bd0 x21 ffffff80405cb600 x20 000000000008001b x19 ffffff8040b3b6e0 x18 0000000000000000 x17 0000000000000000 x16 0000000000000000 x15 696e6920746f6e20 x14 7369203a29343263 x13 205d303434542020 x12 0000000000000000 x11 0000000000000000 x10 0000000000000000 x9 0000000000000000 x8 0000000000000000 x7 0000000000000000 x6 0000000000000000 x5 0000000000000000 x4 0000000000000000 x3 0000000000000000 x2 0000000000000000 x1 0000000000000000 x0 0000000000000000 Call trace kobject_put+0x120/0x150 cdev_put+0x20/0x3c __fput+0x2c4/0x2d8 ____fput+0x1c/0x38 task_work_run+0x70/0xfc do_exit+0x2a0/0x924 do_group_exit+0x34/0x90 get_signal+0x7fc/0x8c0 do_signal+0x128/0x13b4 do_notify_resume+0xdc/0x160 el0_svc+0xd4/0xf8 el0t_64_sync_handler+0x140/0x14c el0t_64_sync+0x190/0x194 ---[ end trace 0000000000000000 ]--- ...followed by more symptoms of corruption, with similar stacks refcount_t underflow use-after-free. kernel BUG at lib/list_debug.c62! Kernel panic - not syncing Oops - BUG Fatal exception This happens because pps_device_destruct() frees the pps_device with the embedded cdev immediately after calling cdev_del(), but, as the comment above cdev_del() notes, fops for previously opened cdevs are still callable even after cdev_del() returns. I think this bug has always been there I cant explain why it suddenly started happening every time I reboot this particular board. In commit d953e0e837e6 (pps Fix a use-after free bug when unregistering a source.), George Spelvin suggested removing the embedded cdev. That seems like the simplest way to fix this, so Ive implemented his suggestion, using __register_chrdev() with pps_idr becoming the source of truth for which minor corresponds to which device. But now that pps_idr defines userspace visibility instead of cdev_add(), we need to be sure the pps->dev refcount cant reach zero while userspace can still find it again. So, the idr_remove() call moves to pps_unregister_cdev(), and pps_idr now holds a reference to pps->dev. pps_core source serial1 got cdev (2511) pps pps1 removed pps_core unregistering pps1 pps_core deallocating pps1",
    "keyphrases": {
        "rootcause": "",
        "weakness": "use-after-free",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "",
        "version": "6.11.0-rc6-00308-gb31c44928842",
        "component": "Linux kernel"
    }
}
