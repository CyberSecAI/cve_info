{
    "cveId": "CVE-2024-44946",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved kcm Serialise kcm_sendmsg() for the same socket. syzkaller reported UAF in kcm_release(). [0] The scenario is 1. Thread A builds a skb with MSG_MORE and sets kcm->seq_skb. 2. Thread A resumes building skb from kcm->seq_skb but is blocked by sk_stream_wait_memory() 3. Thread B calls sendmsg() concurrently, finishes building kcm->seq_skb and puts the skb to the write queue 4. Thread A faces an error and finally frees skb that is already in the write queue 5. kcm_release() does double-free the skb in the write queue When a thread is building a MSG_MORE skb, another thread must not touch it. Lets add a per-sk mutex and serialise kcm_sendmsg(). [0] BUG KASAN slab-use-after-free in __skb_unlink include/linux/skbuff.h2366 [inline] BUG KASAN slab-use-after-free in __skb_dequeue include/linux/skbuff.h2385 [inline] BUG KASAN slab-use-after-free in __skb_queue_purge_reason include/linux/skbuff.h3175 [inline] BUG KASAN slab-use-after-free in __skb_queue_purge include/linux/skbuff.h3181 [inline] BUG KASAN slab-use-after-free in kcm_release+0x170/0x4c8 net/kcm/kcmsock.c1691 Read of size 8 at addr ffff0000ced0fc80 by task syz-executor329/6167 CPU 1 PID 6167 Comm syz-executor329 Tainted G B 6.8.0-rc5-syzkaller-g9abbc24128bc #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024 Call trace dump_backtrace+0x1b8/0x",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "use-after-free",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.8.0-rc5",
        "component": "kcm_release()"
    }
}
