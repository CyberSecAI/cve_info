{
    "cveId": "CVE-2024-44952",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved driver core Fix uevent_show() vs driver detach race uevent_show() wants to de-reference dev->driver->name. There is no clean way for a device attribute to de-reference dev->driver unless that attribute is defined via (struct device_driver).dev_groups. Instead, the anti-pattern of taking the device_lock() in the attribute handler risks deadlocks with code paths that remove device attributes while holding the lock. This deadlock is typically invisible to lockdep given the device_lock() is marked lockdep_set_novalidate_class(), but some subsystems allocate a local lockdep key for @dev->mutex to reveal reports of the form ====================================================== WARNING possible circular locking dependency detected 6.10.0-rc7+ #275 Tainted G OE N ------------------------------------------------------ modprobe/2374 is trying to acquire lock ffff8c2270070de0 (kn->active#6){++++}-{00}, at __kernfs_remove+0xde/0x220 but task is already holding lock ffff8c22016e88f8 (&cxl_root_key){+.+.}-{33}, at device_release_driver_internal+0x39/0x210 which lock already depends on the new lock. the existing dependency chain (in reverse order) is -> #1 (&cxl_root_key){+.+.}-{33} __mutex_lock+0x99/0xc30 uevent_show+0xac/0x130 dev_attr_show+0x18/0x40 sysfs_kf_seq_show+0xac/0xf0 seq_read_iter+0x110/0x450 vfs_read+0x25b/0x340",
    "keyphrases": {
        "rootcause": "race condition between uevent_show() and driver detach",
        "weakness": "deadlock",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.10.0-rc7+",
        "component": ""
    }
}
