{
    "cveId": "CVE-2024-44937",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved platform/x86 intel-vbtn Protect ACPI notify handler against recursion Since commit e2ffcda16290 (ACPI OSL Allow Notify () handlers to run on all CPUs) ACPI notify handlers like the intel-vbtn notify_handler() may run on multiple CPU cores racing with themselves. This race gets hit on Dell Venue 7140 tablets when undocking from the keyboard, causing the handler to try and register priv->switches_dev twice, as can be seen from the dev_info() message getting logged twice [ 83.861800] intel-vbtn INT33D600 Registering Intel Virtual Switches input-dev after receiving a switch event [ 83.861858] input Intel Virtual Switches as /devices/pci000000/0000001f.0/PNP0C0900/INT33D600/input/input17 [ 83.861865] intel-vbtn INT33D600 Registering Intel Virtual Switches input-dev after receiving a switch event After which things go seriously wrong [ 83.861872] sysfs cannot create duplicate filename /devices/pci000000/0000001f.0/PNP0C0900/INT33D600/input/input17 ... [ 83.861967] kobject kobject_add_internal failed for input17 with -EEXIST, dont try to register things with the same name in the same directory. [ 83.877338] BUG kernel NULL pointer dereference, address 0000000000000018 ... Protect intel-vbtn notify_handler() from racing with itself with a mutex to fix this.",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "NULL pointer dereference",
        "vector": "concurrent execution",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "ACPI notify handlers"
    }
}
