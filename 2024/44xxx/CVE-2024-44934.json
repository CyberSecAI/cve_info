{
    "cveId": "CVE-2024-44934",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net bridge mcast wait for previous gc cycles when removing port syzbot hit a use-after-free[1] which is caused because the bridge doesnt make sure that all previous garbage has been collected when removing a port. What happens is CPU 1 CPU 2 start gc cycle remove port acquire gc lock first wait for lock call br_multicasg_gc() directly acquire lock now but free port the port can be freed while grp timers still running Make sure all previous gc cycles have finished by using flush_work before freeing the port. [1] BUG KASAN slab-use-after-free in br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c861 Read of size 8 at addr ffff888071d6d000 by task syz.5.1232/9699 CPU 1 PID 9699 Comm syz.5.1232 Not tainted 6.10.0-rc5-syzkaller-00021-g24ca36a562d6 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 06/07/2024 Call Trace __dump_stack lib/dump_stack.c88 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c114 print_address_description mm/kasan/report.c377 [inline] print_report+0xc3/0x620 mm/kasan/report.c488 kasan_report+0xd9/0x110 mm/kasan/report.c601 br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c861 call_timer_fn+0x1a3/0x610 kernel/time/timer.c1792 expire_timers kernel/time/timer.c1843 [",
    "keyphrases": {
        "rootcause": "doesnt make sure that all previous garbage has been collected when removing a port",
        "weakness": "use-after-free",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "net bridge mcast wait for previous gc cycles when removing port"
    }
}
