{
    "cveId": "CVE-2024-47706",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved block, bfq fix possible UAF for bfqq->bic with merge chain 1) initial state, three tasks Process 1 Process 2Process 3 (BIC1) (BIC2) (BIC3) | | | | | | | | | V | V | V | bfqq1 bfqq2 bfqq3 process ref 1 1 1 2) bfqq1 merged to bfqq2 Process 1 Process 2Process 3 (BIC1) (BIC2) (BIC3) | | | \\--------------\\| | | V V | bfqq1--------->bfqq2 bfqq3 process ref 0 2 1 3) bfqq2 merged to bfqq3 Process 1 Process 2Process 3 (BIC1) (BIC2) (BIC3) here -> | | \\--------------\\ \\-------------\\| V V bfqq1--------->bfqq2---------->bfqq3 process ref 0 1 3 In this case, IO from Process 1 will get bfqq2 from BIC1 first, and then get bfqq3 through merge chain, and finially handle IO by bfqq3. Howerver, current code will think bfqq2 is owned by BIC1, like initial state, and set bfqq2->bic to BIC1. bfq_insert_request -> by Process 1 bfqq = bfq_init_rq(rq) bfqq = bfq_get_bfqq_handle_split bfqq = bic_to_bfqq -> get bfqq2 from BIC1 bfqq->ref++ rq->elv.priv[0] = bic rq->elv.priv[1] = bfqq if (bfqq_process_refs(bfqq) == 1) bfqq->bic = bic -> record BIC1 to bfqq2 __bfq_insert_request new_bfqq = bfq_setup_cooperator -> get bfqq3 from bfqq2->new_bfqq bfqq_request_freed(bfqq)",
    "keyphrases": {
        "rootcause": "",
        "weakness": "Use-After-Free",
        "impact": "denial of service",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "block, bfq"
    }
}
