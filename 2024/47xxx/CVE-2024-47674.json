{
    "cveId": "CVE-2024-47674",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mm avoid leaving partial pfn mappings around in error case As Jann points out, PFN mappings are special, because unlike normal memory mappings, there is no lifetime information associated with the mapping - it is just a raw mapping of PFNs with no reference counting of a struct page. Thats all very much intentional, but it does mean that its easy to mess up the cleanup in case of errors. Yes, a failed mmap() will always eventually clean up any partial mappings, but without any explicit lifetime in the page table mapping itself, its very easy to do the error handling in the wrong order. In particular, its easy to mistakenly free the physical backing store before the page tables are actually cleaned up and (temporarily) have stale dangling PTE entries. To make this situation less error-prone, just make sure that any partial pfn mapping is torn down early, before any other error handling.",
    "keyphrases": {
        "rootcause": "improper error handling",
        "weakness": "stale dangling PTE entries",
        "impact": "",
        "vector": "partial pfn mappings",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": ""
    }
}
