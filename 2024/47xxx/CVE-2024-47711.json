{
    "cveId": "CVE-2024-47711",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved af_unix Dont return OOB skb in manage_oob(). syzbot reported use-after-free in unix_stream_recv_urg(). [0] The scenario is 1. send(MSG_OOB) 2. recv(MSG_OOB) -> The consumed OOB remains in recv queue 3. send(MSG_OOB) 4. recv() -> manage_oob() returns the next skb of the consumed OOB -> This is also OOB, but unix_sk(sk)->oob_skb is not cleared 5. recv(MSG_OOB) -> unix_sk(sk)->oob_skb is used but already freed The recent commit 8594d9b85c07 (af_unix Dont call skb_get() for OOB skb.) uncovered the issue. If the OOB skb is consumed and the next skb is peeked in manage_oob(), we still need to check if the skb is OOB. Lets do so by falling back to the following checks in manage_oob() and add the test case in selftest. Note that we need to add a similar check for SIOCATMARK. [0] BUG KASAN slab-use-after-free in unix_stream_read_actor+0xa6/0xb0 net/unix/af_unix.c2959 Read of size 4 at addr ffff8880326abcc4 by task syz-executor178/5235 CPU 0 UID 0 PID 5235 Comm syz-executor178 Not tainted 6.11.0-rc5-syzkaller-00742-gfbdaffe41adc #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Call Trace __dump_stack lib/dump_stack.c93 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c119 print_address_description mm/kasan/report.c377 [inline] print_report+0x169/0x550 mm/kasan/report.c488 kasan_report+0x143/0x180 mm/ka"
}
