{
    "cveId": "CVE-2024-26880",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved dm call the resume method on internal suspend There is this reported crash when experimenting with the lvm2 testsuite. The list corruption is caused by the fact that the postsuspend and resume methods were not paired correctly there were two consecutive calls to the origin_postsuspend function. The second call attempts to remove the hash_list entry from a list, while it was already removed by the first call. Fix __dm_internal_resume so that it calls the preresume and resume methods of the tables targets. If a preresume method of some target fails, we are in a tricky situation. We cant return an error because dm_internal_resume isnt supposed to return errors. We cant return success, because then the resume and postsuspend methods would not be paired correctly. So, we set the DMF_SUSPENDED flag and we fake normal suspend - it may confuse userspace tools, but it wont cause a kernel crash. ------------[ cut here ]------------ kernel BUG at lib/list_debug.c56! invalid opcode 0000 [#1] PREEMPT SMP CPU 1 PID 8343 Comm dmsetup Not tainted 6.8.0-rc6 #4 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014 RIP 0010__list_del_entry_valid_or_report+0x77/0xc0 RSP 0018ffff8881b831bcc0 EFLAGS 00010282 RAX 000000000000004e RBX ffff888143b6eb80 RCX 0000000000000000 RDX 0000000000000001 RSI ffffffff819053d0 RDI 00000000ffffffff RBP ffff8881b83a3400 R08 000000",
    "keyphrases": {
        "rootcause": "two consecutive calls to the origin_postsuspend function",
        "weakness": "",
        "impact": "list corruption",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": ""
    }
}
