{
    "cveId": "CVE-2024-26732",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net implement lockless setsockopt(SO_PEEK_OFF) syzbot reported a lockdep violation [1] involving af_unix support of SO_PEEK_OFF. Since SO_PEEK_OFF is inherently not thread safe (it uses a per-socket sk_peek_off field), there is really no point to enforce a pointless thread safety in the kernel. After this patch - setsockopt(SO_PEEK_OFF) no longer acquires the socket lock. - skb_consume_udp() no longer has to acquire the socket lock. - af_unix no longer needs a special version of sk_set_peek_off(), because it does not lock u->iolock anymore. As a followup, we could replace prot->set_peek_off to be a boolean and avoid an indirect call, since we always use sk_set_peek_off(). [1] WARNING possible circular locking dependency detected 6.8.0-rc4-syzkaller-00267-g0f1dd5e91e2b #0 Not tainted syz-executor.2/30025 is trying to acquire lock ffff8880765e7d80 (&u->iolock){+.+.}-{33}, at unix_set_peek_off+0x26/0xa0 net/unix/af_unix.c789 but task is already holding lock ffff8880765e7930 (sk_lock-AF_UNIX){+.+.}-{00}, at lock_sock include/net/sock.h1691 [inline] ffff8880765e7930 (sk_lock-AF_UNIX){+.+.}-{00}, at sockopt_lock_sock net/core/sock.c1060 [inline] ffff8880765e7930 (sk_lock-AF_UNIX){+.+.}-{00}, at sk_setsockopt+0xe52/0x3360 net/core/sock.c1193 which lock already depends on the new lock. the existing dependency chain (in reverse order) is -> #1 (sk_lock-AF_UNIX){+.+.}-{00}",
    "keyphrases": {
        "rootcause": "lockdep violation",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.8.0-rc4-syzkaller-00267-g0f1dd5e91e2b",
        "component": "af_unix support of SO_PEEK_OFF"
    }
}
