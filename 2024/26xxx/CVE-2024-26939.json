{
    "cveId": "CVE-2024-26939",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved drm/i915/vma Fix UAF on destroy against retire race Object debugging tools were sporadically reporting illegal attempts to free a still active i915 VMA object when parking a GT believed to be idle. [161.359441] ODEBUG free active (active state 0) object ffff88811643b958 object type i915_active hint __i915_vma_active+0x0/0x50 [i915] [161.360082] WARNING CPU 5 PID 276 at lib/debugobjects.c514 debug_print_object+0x80/0xb0 ... [161.360304] CPU 5 PID 276 Comm kworker/52 Not tainted 6.5.0-rc1-CI_DRM_13375-g003f860e5577+ #1 [161.360314] Hardware name Intel Corporation Rocket Lake Client Platform/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04/21/2022 [161.360322] Workqueue i915-unordered __intel_wakeref_put_work [i915] [161.360592] RIP 0010debug_print_object+0x80/0xb0 ... [161.361347] debug_object_free+0xeb/0x110 [161.361362] i915_active_fini+0x14/0x130 [i915] [161.361866] release_references+0xfe/0x1f0 [i915] [161.362543] i915_vma_parked+0x1db/0x380 [i915] [161.363129] __gt_park+0x121/0x230 [i915] [161.363515] ____intel_wakeref_put_last+0x1f/0x70 [i915] That has been tracked down to be happening when another thread is deactivating the VMA inside __active_retire() helper, after the VMAs active counter has been already decremented to 0, but before deactivation of the VMAs object is reported to the object debugging tool. We could prevent from that race by serializing i915_act",
    "keyphrases": {
        "rootcause": "UAF on destroy against retire race",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "drm/i915"
    }
}
