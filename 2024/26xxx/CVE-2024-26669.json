{
    "cveId": "CVE-2024-26669",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net/sched flower Fix chain template offload When a qdisc is deleted from a net device the stack instructs the underlying driver to remove its flow offload callback from the associated filter block using the FLOW_BLOCK_UNBIND command. The stack then continues to replay the removal of the filters in the block for this driver by iterating over the chains in the block and invoking the reoffload operation of the classifier being used. In turn, the classifier in its reoffload operation prepares and emits a FLOW_CLS_DESTROY command for each filter. However, the stack does not do the same for chain templates and the underlying driver never receives a FLOW_CLS_TMPLT_DESTROY command when a qdisc is deleted. This results in a memory leak [1] which can be reproduced using [2]. Fix by introducing a tmplt_reoffload operation and have the stack invoke it with the appropriate arguments as part of the replay. Implement the operation in the sole classifier that supports chain templates (flower) by emitting the FLOW_CLS_TMPLT_{CREATE,DESTROY} command based on whether a flow offload callback is being bound to a filter block or being unbound from one. As far as I can tell, the issue happens since cited commit which reordered tcf_block_offload_unbind() before tcf_block_flush_all_chains() in __tcf_block_put(). The order cannot be reversed as the filter block is expected to be freed after flushing all the chains",
    "keyphrases": {
        "rootcause": "improper order of operations",
        "weakness": "memory leak",
        "impact": "",
        "vector": "deleting a qdisc from a net device",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "net/sched flower"
    }
}
