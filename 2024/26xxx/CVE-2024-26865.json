{
    "cveId": "CVE-2024-26865",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved rds tcp Fix use-after-free of net in reqsk_timer_handler(). syzkaller reported a warning of netns tracker [0] followed by KASAN splat [1] and another ref tracker warning [1]. syzkaller could not find a repro, but in the log, the only suspicious sequence was as follows 182622 executing program 1 r0 = socket$inet6_mptcp(0xa, 0x1, 0x106) ... connect$inet6(r0, &(0x7f0000000080)={0xa, 0x4001, 0x0, @loopback}, 0x1c) (async) The notable thing here is 0x4001 in connect(), which is RDS_TCP_PORT. So, the scenario would be 1. unshare(CLONE_NEWNET) creates a per netns tcp listener in rds_tcp_listen_init(). 2. syz-executor connect()s to it and creates a reqsk. 3. syz-executor exit()s immediately. 4. netns is dismantled. [0] 5. reqsk timer is fired, and UAF happens while freeing reqsk. [1] 6. listener is freed after RCU grace period. [2] Basically, reqsk assumes that the listener guarantees netns safety until all reqsk timers are expired by holding the listeners refcount. However, this was not the case for kernel sockets. Commit 740ea3c4a0b2 (tcp Clean up kernel listeners reqsk in inet_twsk_purge()) fixed this issue only for per-netns ehash. Lets apply the same fix for the global ehash. [0] ref_tracker net notrefcnt@0000000065449cc3 has 1/1 users at sk_alloc (./include/net/net_namespace.h337 net/core/sock.c2146) inet6_create (net/ipv6/af_inet6.c192 net/ipv",
    "keyphrases": {
        "rootcause": "use-after-free",
        "weakness": "",
        "impact": "",
        "vector": "connect to RDS_TCP_PORT",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "reqsk_timer_handler()"
    }
}
