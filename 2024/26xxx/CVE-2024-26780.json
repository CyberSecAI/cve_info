{
    "cveId": "CVE-2024-26780",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved af_unix Fix task hung while purging oob_skb in GC. syzbot reported a task hung at the same time, GC was looping infinitely in list_for_each_entry_safe() for OOB skb. [0] syzbot demonstrated that the list_for_each_entry_safe() was not actually safe in this case. A single skb could have references for multiple sockets. If we free such a skb in the list_for_each_entry_safe(), the current and next sockets could be unlinked in a single iteration. unix_notinflight() uses list_del_init() to unlink the socket, so the prefetched next socket forms a loop itself and list_for_each_entry_safe() never stops. Here, we must use while() and make sure we always fetch the first socket. [0] Sending NMI from CPU 0 to CPUs 1 NMI backtrace for cpu 1 CPU 1 PID 5065 Comm syz-executor236 Not tainted 6.8.0-rc3-syzkaller-00136-g1f719a2f3fa6 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024 RIP 0010preempt_count arch/x86/include/asm/preempt.h26 [inline] RIP 0010check_kcov_mode kernel/kcov.c173 [inline] RIP 0010__sanitizer_cov_trace_pc+0xd/0x60 kernel/kcov.c207 Code cc cc cc cc 66 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 65 48 8b 14 25 40 c2 03 00 8b 05 b4 7c 78 7e a9 00 01 ff 00 48 8b 34 24 74 0f f6 c4 01 74 RSP 0018ffffc900033efa58 EFLAGS 00000283 RAX ffff88807b077800 RBX ffff88807b077800 RCX 1ffffffff27b1189 RDX f"
}
