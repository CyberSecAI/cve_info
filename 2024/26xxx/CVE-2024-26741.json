{
    "cveId": "CVE-2024-26741",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved dccp/tcp Unhash sk from ehash for tb2 alloc failure after check_estalblished(). syzkaller reported a warning [0] in inet_csk_destroy_sock() with no repro. WARN_ON(inet_sk(sk)->inet_num && !inet_csk(sk)->icsk_bind_hash) However, the syzkallers log hinted that connect() failed just before the warning due to FAULT_INJECTION. [1] When connect() is called for an unbound socket, we search for an available ephemeral port. If a bhash bucket exists for the port, we call __inet_check_established() or __inet6_check_established() to check if the bucket is reusable. If reusable, we add the socket into ehash and set inet_sk(sk)->inet_num. Later, we look up the corresponding bhash2 bucket and try to allocate it if it does not exist. Although it rarely occurs in real use, if the allocation fails, we must revert the changes by check_established(). Otherwise, an unconnected socket could illegally occupy an ehash entry. Note that we do not put tw back into ehash because sk might have already responded to a packet for tw and it would be better to free tw earlier under such memory presure. [0] WARNING CPU 0 PID 350830 at net/ipv4/inet_connection_sock.c1193 inet_csk_destroy_sock (net/ipv4/inet_connection_sock.c1193) Modules linked in Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP 0010inet_csk_destroy_sock (net/ipv4/inet_connection_s",
    "keyphrases": {
        "rootcause": "connect() failure",
        "weakness": "",
        "impact": "illegal occupy an ehash entry",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "dccp/tcp"
    }
}
