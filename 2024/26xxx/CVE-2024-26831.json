{
  "cveId": "CVE-2024-26831",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved net/handshake Fix handshake_req_destroy_test1 Recently, handshake_req_destroy_test1 started failing Expected handshake_req_destroy_test == req, but handshake_req_destroy_test == 0000000000000000 req == 0000000060f99b40 not ok 11 req_destroy works This is because sock_release(sock) was replaced with fput(filp) to address a memory leak. Note that sock_release() is synchronous but fput() usually delays the final close and clean-up. The delay is not consequential in the other cases that were changed but handshake_req_destroy_test1 is testing that handshake_req_cancel() followed by closing the file actually does call the ->hp_destroy method. Thus the PTR_EQ test at the end has to be sure that the final close is complete before it checks the pointer. We cannot use a completion here because if ->hp_destroy is never called (ie, there is an API bug) then the test will hang. Reported by Guenter Roeck",
  "keyphrases": {
    "rootcause": "sock_release(sock) was replaced with fput(filp)",
    "weakness": "memory leak",
    "impact": "",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "net/handshake"
  },
  "mitreTechnicalImpacts": []
}