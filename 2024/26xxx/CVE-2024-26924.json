{
    "cveId": "CVE-2024-26924",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved netfilter nft_set_pipapo do not free live element Pablo reports a crash with large batches of elements with a back-to-back add/remove pattern. Quoting Pablo add_elem(00000000) timeout 100 ms ... add_elem(0000000X) timeout 100 ms del_elem(0000000X) <---------------- delete one that was just added ... add_elem(00005000) timeout 100 ms 1) nft_pipapo_remove() removes element 0000000X Then, KASAN shows a splat. Looking at the remove function there is a chance that we will drop a rule that maps to a non-deactivated element. Removal happens in two steps, first we do a lookup for key k and return the to-be-removed element and mark it as inactive in the next generation. Then, in a second step, the element gets removed from the set/map. The _remove function does not work correctly if we have more than one element that share the same key. This can happen if we insert an element into a set when the set already holds an element with same key, but the element mapping to the existing key has timed out or is not active in the next generation. In such case its possible that removal will unmap the wrong element. If this happens, we will leak the non-deactivated element, it becomes unreachable. The element that got deactivated (and will be freed later) will remain reachable in the set data structure, this can result in a crash when such an element is retrieved during lookup (stale pointer).",
    "keyphrases": {
        "rootcause": "",
        "weakness": "use-after-free, stale pointer",
        "impact": "crash",
        "vector": "large batches of elements with back-to-back add/remove pattern",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "netfilter nft_set_pipapo"
    }
}
