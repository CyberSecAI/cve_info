{
  "cveId": "CVE-2024-26906",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved x86/mm Disallow vsyscall page read for copy_from_kernel_nofault() When trying to use copy_from_kernel_nofault() to read vsyscall page through a bpf program, the following oops was reported BUG unable to handle page fault for address ffffffffff600000 #PF supervisor read access in kernel mode #PF error_code(0x0000) - not-present page PGD 3231067 P4D 3231067 PUD 3233067 PMD 3235067 PTE 0 Oops 0000 [#1] PREEMPT SMP PTI CPU 1 PID 20390 Comm test_progs ...... 6.7.0+ #58 Hardware name QEMU Standard PC (i440FX + PIIX, 1996) ...... RIP 0010copy_from_kernel_nofault+0x6f/0x110 ...... Call Trace ? copy_from_kernel_nofault+0x6f/0x110 bpf_probe_read_kernel+0x1d/0x50 bpf_prog_2061065e56845f08_do_probe_read+0x51/0x8d trace_call_bpf+0xc5/0x1c0 perf_call_bpf_enter.isra.0+0x69/0xb0 perf_syscall_enter+0x13e/0x200 syscall_trace_enter+0x188/0x1c0 do_syscall_64+0xb5/0xe0 entry_SYSCALL_64_after_hwframe+0x6e/0x76 ...... ---[ end trace 0000000000000000 ]--- The oops is triggered when 1) A bpf program uses bpf_probe_read_kernel() to read from the vsyscall page and invokes copy_from_kernel_nofault() which in turn calls __get_user_asm(). 2) Because the vsyscall page address is not readable from kernel space, a page fault exception is triggered accordingly. 3) handle_page_fault() considers the vsyscall page address as a user space address instead",
  "keyphrases": {
    "rootcause": "BUG unable to handle page fault for address ffffffffff600000",
    "weakness": "",
    "impact": [
      "oops",
      "read access"
    ],
    "vector": "bpf program",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "x86/mm"
  },
  "mitreTechnicalImpacts": []
}