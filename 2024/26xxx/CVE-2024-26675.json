{
    "cveId": "CVE-2024-26675",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvedppp_async limit MRU to 64Ksyzbot triggered a warning [1] in __alloc_pages()WARN_ON_ONCE_GFP(order > MAX_PAGE_ORDER, gfp)Willem fixed a similar issue in commit c0a2a1b0d631 (ppp limit MRU to 64K)Adopt the same sanity check for ppp_async_ioctl(PPPIOCSMRU)[1] WARNING CPU 1 PID 11 at mm/page_alloc.c4543 __alloc_pages+0x308/0x698 mm/page_alloc.c4543Modules linked inCPU 1 PID 11 Comm kworker/u40 Not tainted 6.8.0-rc2-syzkaller-g41bccc98fb79 #0Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023Workqueue events_unbound flush_to_ldiscpstate 204000c5 (nzCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc __alloc_pages+0x308/0x698 mm/page_alloc.c4543 lr __alloc_pages+0xc8/0x698 mm/page_alloc.c4537sp ffff800093967580x29 ffff800093967660 x28 ffff8000939675a0 x27 dfff800000000000x26 ffff70001272ceb4 x25 0000000000000000 x24 ffff8000939675c0x23 0000000000000000 x22 0000000000060820 x21 1ffff0001272ceb8x20 ffff8000939675e0 x19 0000000000000010 x18 ffff800093967120x17 ffff800083bded5c x16 ffff80008ac97500 x15 0000000000000005x14 1ffff0001272cebc x13 0000000000000000 x12 0000000000000000x11 ffff70001272cec1 x10 1ffff0001272cec0 x9 0000000000000001x8 ffff800091c91000 x7 0000000000000000 x6 000000000000003fx5 00000000ffffffff x4 0000000000000000 x3 0000000000000020x2 0000000000000008 x1 0000000000000000 x0 ffff8000939675e0Call trace __alloc_pages+0x308/0x698 mm/page_alloc.c4543 __alloc_pages_node include/linux/gfp.h238 [inline] alloc_pages_node include/linux/gfp.h261 [inline] __kmalloc_large_node+0xbc/0x1fc mm/slub.c3926 __do_kmalloc_node mm/slub.c3969 [inline] __kmalloc_node_track_caller+0x418/0x620 mm/slub.c4001 kmalloc_reserve+0x17c/0x23c net/core/skbuff.c590 __alloc_skb+0x1c8/0x3d8 net/core/skbuff.c651 __netdev_alloc_skb+0xb8/0x3e8 net/core/skbuff.c715 netdev_alloc_skb include/linux/skbuff.h3235 [inline] dev_alloc_skb include/linux/skbuff.h3248 [inline] ppp_async_input drivers/net/ppp/ppp_async.c863 [inline] ppp_asynctty_receive+0x588/0x186c drivers/net/ppp/ppp_async.c341 tty_ldisc_receive_buf+0x12c/0x15c drivers/tty/tty_buffer.c390 tty_port_default_receive_buf+0x74/0xac drivers/tty/tty_port.c37 receive_buf drivers/tty/tty_buffer.c444 [inline] flush_to_ldisc+0x284/0x6e4 drivers/tty/tty_buffer.c494 process_one_work+0x694/0x1204 kernel/workqueue.c2633 process_scheduled_works kernel/workqueue.c2706 [inline] worker_thread+0x938/0xef4 kernel/workqueue.c2787 kthread+0x288/0x310 kernel/kthread.c388 ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S860",
    "keyphrases": {
        "rootcause": "The ppp_async driver does not properly validate the MRU value set via ioctl, allowing a user to request an allocation of a large page size which can cause a kernel warning and memory allocation issues.",
        "weakness": "Improper input validation of the MRU value in ppp_async_ioctl, leading to excessive memory allocation.",
        "impact": "Kernel warning due to allocation failure, potentially leading to denial of service or other issues related to memory exhaustion.",
        "vector": "Local, through ioctl interface (PPPIOCSMRU).",
        "attacker": "A local user with access to the ppp_async device.",
        "product": "Linux Kernel",
        "version": "Versions before the fix (6.8-rc2)",
        "component": "ppp_async driver"
    }
}
