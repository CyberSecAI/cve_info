{
    "cveId": "CVE-2024-26859",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net/bnx2x Prevent access to a freed page in page_pool Fix race condition leading to system crash during EEH error handling During EEH error recovery, the bnx2x drivers transmit timeout logic could cause a race condition when handling reset tasks. The bnx2x_tx_timeout() schedules reset tasks via bnx2x_sp_rtnl_task(), which ultimately leads to bnx2x_nic_unload(). In bnx2x_nic_unload() SGEs are freed using bnx2x_free_rx_sge_range(). However, this could overlap with the EEH drivers attempt to reset the device using bnx2x_io_slot_reset(), which also tries to free SGEs. This race condition can result in system crashes due to accessing freed memory locations in bnx2x_free_rx_sge() 799 static inline void bnx2x_free_rx_sge(struct bnx2x *bp, 800struct bnx2x_fastpath *fp, u16 index) 801 { 802struct sw_rx_page *sw_buf = &fp->rx_page_ring[index] 803 struct page *page = sw_buf->page .... where sw_buf was set to NULL after the call to dma_unmap_page() by the preceding thread. EEH Beginning slot_reset PCI 00110100.0#10000 EEH Invoking bnx2x->slot_reset() bnx2x [bnx2x_io_slot_reset14228(eth1)]IO slot reset initializing... bnx2x 00110100.0 enabling device (0140 -> 0142) bnx2x [bnx2x_io_slot_reset14244(eth1)]IO slot reset --> driver unload Kernel attempted to read user page (0) - exploit attempt? (uid 0) BUG Kernel NULL pointer dereference on read at 0x00000000 Fa",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "use-after-free",
        "impact": "system crash",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "net/bnx2x"
    }
}
