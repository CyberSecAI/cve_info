{
    "cveId": "CVE-2024-26792",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs fix double free of anonymous device after snapshot creation failure When creating a snapshot we may do a double free of an anonymous device in case theres an error committing the transaction. The second free may result in freeing an anonymous device number that was allocated by some other subsystem in the kernel or another btrfs filesystem. The steps that lead to this 1) At ioctl.ccreate_snapshot() we allocate an anonymous device number and assign it to pending_snapshot->anon_dev 2) Then we call btrfs_commit_transaction() and end up at transaction.ccreate_pending_snapshot() 3) There we call btrfs_get_new_fs_root() and pass it the anonymous device number stored in pending_snapshot->anon_dev 4) btrfs_get_new_fs_root() frees that anonymous device number because btrfs_lookup_fs_root() returned a root - someone else did a lookup of the new root already, which could some task doing backref walking 5) After that some error happens in the transaction commit path, and at ioctl.ccreate_snapshot() we jump to the fail label, and after that we free again the same anonymous device number, which in the meanwhile may have been reallocated somewhere else, because pending_snapshot->anon_dev still has the same value as in step 1. Recently syzbot ran into this and reported the following trace ------------[ cut here ]------------ ida_free called for id=51 which is not al",
    "keyphrases": {
        "rootcause": "",
        "weakness": "double free",
        "impact": "use-after-free",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs"
    }
}
