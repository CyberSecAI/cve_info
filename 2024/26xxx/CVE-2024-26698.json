{
    "cveId": "CVE-2024-26698",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved hv_netvsc Fix race condition between netvsc_probe and netvsc_remove In commit ac5047671758 (hv_netvsc Disable NAPI before closing the VMBus channel), napi_disable was getting called for all channels, including all subchannels without confirming if they are enabled or not. This caused hv_netvsc getting hung at napi_disable, when netvsc_probe() has finished running but nvdev->subchan_work has not started yet. netvsc_subchan_work() -> rndis_set_subchannel() has not created the sub-channels and because of that netvsc_sc_open() is not running. netvsc_remove() calls cancel_work_sync(&nvdev->subchan_work), for which netvsc_subchan_work did not run. netif_napi_add() sets the bit NAPI_STATE_SCHED because it ensures NAPI cannot be scheduled. Then netvsc_sc_open() -> napi_enable will clear the NAPIF_STATE_SCHED bit, so it can be scheduled. napi_disable() does the opposite. Now during netvsc_device_remove(), when napi_disable is called for those subchannels, napi_disable gets stuck on infinite msleep. This fix addresses this problem by ensuring that napi_disable() is not getting called for non-enabled NAPI struct. But netif_napi_del() is still necessary for these non-enabled NAPI struct for cleanup purpose. Call trace [ 654.559417] taskmodprobe stateD stack 0 pid 2321 ppid 1091 flags0x00004002 [ 654.568030] Call Trace [ 654.571221] [ 654.573790] __schedule+0x2d6/0x960 [ 654.577",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "hv_netvsc getting hung at napi_disable",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "hv_netvsc"
    }
}
