{
    "cveId": "CVE-2024-26750",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved af_unix Drop oob_skb ref before purging queue in GC. syzbot reported another task hung in __unix_gc(). [0] The current while loop assumes that all of the left candidates have oob_skb and calling kfree_skb(oob_skb) releases the remaining candidates. However, I missed a case that oob_skb has self-referencing fd and another fd and the latter sk is placed before the former in the candidate list. Then, the while loop never proceeds, resulting the task hung. __unix_gc() has the same loop just before purging the collected skb, so we can call kfree_skb(oob_skb) there and let __skb_queue_purge() release all inflight sockets. [0] Sending NMI from CPU 0 to CPUs 1 NMI backtrace for cpu 1 CPU 1 PID 2784 Comm kworker/u48 Not tainted 6.8.0-rc4-syzkaller-01028-g71b605d32017 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024 Workqueue events_unbound __unix_gc RIP 0010__sanitizer_cov_trace_pc+0x0/0x70 kernel/kcov.c200 Code 89 fb e8 23 00 00 00 48 8b 3d 84 f5 1a 0c 48 89 de 5b e9 43 26 57 00 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1e fa 48 8b 04 24 65 48 8b 0d 90 52 70 7e 65 8b 15 91 52 70 RSP 0018ffffc9000a17fa78 EFLAGS 00000287 RAX ffffffff8a0a6108 RBX ffff88802b6c2640 RCX ffff88802c0b3b80 RDX 0000000000000000 RSI 0000000000000002 RDI 0000000000000000 RBP ffffc9000a17fbf0 R08 ffffffff89383f1d R09 1ffff1100ee5ff84 R10 dffffc0000"
}
