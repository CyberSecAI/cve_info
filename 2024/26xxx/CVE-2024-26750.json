{
    "cveId": "CVE-2024-26750",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvedaf_unix Drop oob_skb ref before purging queue in GC.syzbot reported another task hung in __unix_gc(). [0]The current while loop assumes that all of the left candidateshave oob_skb and calling kfree_skb(oob_skb) releases the remainingcandidates.However, I missed a case that oob_skb has self-referencing fd andanother fd and the latter sk is placed before the former in thecandidate list. Then, the while loop never proceeds, resultingthe task hung.__unix_gc() has the same loop just before purging the collected skb,so we can call kfree_skb(oob_skb) there and let __skb_queue_purge()release all inflight sockets.[0]Sending NMI from CPU 0 to CPUs 1NMI backtrace for cpu 1CPU 1 PID 2784 Comm kworker/u48 Not tainted 6.8.0-rc4-syzkaller-01028-g71b605d32017 #0Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024Workqueue events_unbound __unix_gcRIP 0010__sanitizer_cov_trace_pc+0x0/0x70 kernel/kcov.c200Code 89 fb e8 23 00 00 00 48 8b 3d 84 f5 1a 0c 48 89 de 5b e9 43 26 57 00 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1e fa 48 8b 04 24 65 48 8b 0d 90 52 70 7e 65 8b 15 91 52 70RSP 0018ffffc9000a17fa78 EFLAGS 00000287RAX ffffffff8a0a6108 RBX ffff88802b6c2640 RCX ffff88802c0b3b80RDX 0000000000000000 RSI 0000000000000002 RDI 0000000000000000RBP ffffc9000a17fbf0 R08 ffffffff89383f1d R09 1ffff1100ee5ff84R10 dffffc0000000000 R11 ffffed100ee5ff85 R12 1ffff110056d84eeR13 ffffc9000a17fae0 R14 0000000000000000 R15 ffffffff8f47b840FS 0000000000000000(0000) GSffff8880b9500000(0000) knlGS0000000000000000CS 0010 DS 0000 ES 0000 CR0 0000000080050033CR2 00007ffef5687ff8 CR3 0000000029b34000 CR4 00000000003506f0DR0 0000000000000000 DR1 0000000000000000 DR2 0000000000000000DR3 0000000000000000 DR6 00000000fffe0ff0 DR7 0000000000000400Call Trace __unix_gc+0xe69/0xf40 net/unix/garbage.c343 process_one_work kernel/workqueue.c2633 [inline] process_scheduled_works+0x913/0x1420 kernel/workqueue.c2706 worker_thread+0xa5f/0x1000 kernel/workqueue.c2787 kthread+0x2ef/0x390 kernel/kthread.c388 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c147 ret_from_fork_asm+0x1b/0x30 arch/x86/entry/entry_64.S242",
    "keyphrases": {
        "rootcause": "The while loop in __unix_gc() assumes all candidates have oob_skb and calling kfree_skb(oob_skb) releases all candidates, but a self-referencing fd can cause the loop to not proceed and results in a hang.",
        "weakness": "The loop in __unix_gc() doesn't handle self-referencing file descriptors in oob_skb correctly, leading to an infinite loop when the candidate list is not properly handled.",
        "impact": "A task hangs in __unix_gc(), leading to a denial-of-service condition.",
        "vector": "The vulnerability can be triggered by a crafted sequence of operations involving Unix domain sockets and file descriptors that creates a self-referencing fd in oob_skb.",
        "attacker": "An attacker with the ability to create and manipulate Unix domain sockets.",
        "product": "Linux Kernel",
        "version": "6.8.0-rc4",
        "component": "net/unix"
    }
}
