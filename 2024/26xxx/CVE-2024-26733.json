{
    "cveId": "CVE-2024-26733",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved arp Prevent overflow in arp_req_get(). syzkaller reported an overflown write in arp_req_get(). [0] When ioctl(SIOCGARP) is issued, arp_req_get() looks up an neighbour entry and copies neigh->ha to struct arpreq.arp_ha.sa_data. The arp_ha here is struct sockaddr, not struct sockaddr_storage, so the sa_data buffer is just 14 bytes. In the splat below, 2 bytes are overflown to the next int field, arp_flags. We initialise the field just after the memcpy(), so its not a problem. However, when dev->addr_len is greater than 22 (e.g. MAX_ADDR_LEN), arp_netmask is overwritten, which could be set as htonl(0xFFFFFFFFUL) in arp_ioctl() before calling arp_req_get(). To avoid the overflow, lets limit the max length of memcpy(). Note that commit b5f0de6df6dc (net dev Convert sa_data to flexible array in struct sockaddr) just silenced syzkaller. [0] memcpy detected field-spanning write (size 16) of single field r->arp_ha.sa_data at net/ipv4/arp.c1128 (size 14) WARNING CPU 0 PID 144638 at net/ipv4/arp.c1128 arp_req_get+0x411/0x4a0 net/ipv4/arp.c1128 Modules linked in CPU 0 PID 144638 Comm syz-executor.4 Not tainted 6.1.74 #31 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-5 04/01/2014 RIP 0010arp_req_get+0x411/0x4a0 net/ipv4/arp.c1128 Code fd ff ff e8 41 42 de fb b9 0e 00 00 00 4c 89 fe 48 c7 c2 20 6d ab 87 48 c7 c7 80 6d ab 87 c6 05 25 af 72 04 01 e8 5f 8d"
}
