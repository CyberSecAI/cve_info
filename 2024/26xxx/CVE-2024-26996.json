{
    "cveId": "CVE-2024-26996",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved usb gadget f_ncm Fix UAF ncm object at re-bind after usb ep transport error When ncm function is working and then stop usb0 interface for link down, eth_stop() is called. At this piont, accidentally if usb transport error should happen in usb_ep_enable(), in_ep and/or out_ep may not be enabled. After that, ncm_disable() is called to disable for ncm unbind but gether_disconnect() is never called since in_ep is not enabled. As the result, ncm object is released in ncm unbind but dev->port_usb associated to ncm->port is not NULL. And when ncm bind again to recover netdev, ncm object is reallocated but usb0 interface is already associated to previous released ncm object. Therefore, once usb0 interface is up and eth_start_xmit() is called, released ncm object is dereferrenced and it might cause use-after-free memory. [function unlink via configfs] usb0 eth_stop dev->port_usb=ffffff9b179c3200 --> error happens in usb_ep_enable(). NCM ncm_disable ncm=ffffff9b179c3200 --> no gether_disconnect() since ncm->port.in_ep->enabled is false. NCM ncm_unbind ncm unbind ncm=ffffff9b179c3200 NCM ncm_free ncm free ncm=ffffff9b179c3200 port_usb=ffffff9b179c3200 <-- previous releas",
    "keyphrases": {
        "rootcause": "",
        "weakness": "use-after-free",
        "impact": "",
        "vector": "usb transport error",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "usb gadget f_ncm"
    }
}
