{
    "cveId": "CVE-2024-36972",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved af_unix Update unix_sk(sk)->oob_skb under sk_receive_queue lock. Billy Jheng Bing-Jhong reported a race between __unix_gc() and queue_oob(). __unix_gc() tries to garbage-collect close()d inflight sockets, and then if the socket has MSG_OOB in unix_sk(sk)->oob_skb, GC will drop the reference and set NULL to it locklessly. However, the peer socket still can send MSG_OOB message and queue_oob() can update unix_sk(sk)->oob_skb concurrently, leading NULL pointer dereference. [0] To fix the issue, lets update unix_sk(sk)->oob_skb under the sk_receive_queues lock and take it everywhere we touch oob_skb. Note that we defer kfree_skb() in manage_oob() to silence lockdep false-positive (See [1]). [0] BUG kernel NULL pointer dereference, address 0000000000000008 PF supervisor write access in kernel mode PF error_code(0x0002) - not-present page PGD 8000000009f5e067 P4D 8000000009f5e067 PUD 9f5d067 PMD 0 Oops 0002 [#1] PREEMPT SMP PTI CPU 3 PID 50 Comm kworker/31 Not tainted 6.9.0-rc5-00191-gd091e579b864 #110 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 Workqueue events delayed_fput RIP 0010skb_dequeue (./include/linux/skbuff.h2386 ./include/linux/skbuff.h2402 net/core/skbuff.c3847) Code 39 e3 74 3e 8b 43 10 48 89 ef 83 e8 01 89 43 10 49 8b 44 24 08 49 c7 44 24 08 00 00 00 00 49 8b 14 24 49 c7 04 24 00 00 00 00 89 42 0",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "NULL pointer dereference",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "af_unix"
    }
}
