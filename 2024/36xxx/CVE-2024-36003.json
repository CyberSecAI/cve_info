{
    "cveId": "CVE-2024-36003",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved ice fix LAG and VF lock dependency in ice_reset_vf() 9f74a3dfcf83 (ice Fix VF Reset paths when interface in a failed over aggregate), the ice driver has acquired the LAG mutex in ice_reset_vf(). The commit placed this lock acquisition just prior to the acquisition of the VF configuration lock. If ice_reset_vf() acquires the configuration lock via the ICE_VF_RESET_LOCK flag, this could deadlock with ice_vc_cfg_qs_msg() because it always acquires the locks in the order of the VF configuration lock and then the LAG mutex. Lockdep reports this violation almost immediately on creating and then removing 2 VF ====================================================== WARNING possible circular locking dependency detected 6.8.0-rc6 #54 Tainted G W O ------------------------------------------------------ kworker/603/6771 is trying to acquire lock ff40d43e099380a0 (&vf->cfg_lock){+.+.}-{33}, at ice_reset_vf+0x22f/0x4d0 [ice] but task is already holding lock ff40d43ea1961210 (&pf->lag_mutex){+.+.}-{33}, at ice_reset_vf+0xb7/0x4d0 [ice] which lock already depends on the new lock. the existing dependency chain (in reverse order) is -> #1 (&pf->lag_mutex){+.+.}-{33} __lock_acquire+0x4f8/0xb40 lock_acquire+0xd4/0x2d0 __mutex_lock+0x9b/0xbf0 ice_vc_cfg_qs_msg+0x45/0x690 [ice] ice_vc_process_vf_msg+0x4f5/0x870 [ice] __ice_clean_ctrlq+0x2b5/0x600 [ice]",
    "keyphrases": {
        "rootcause": "circular locking dependency",
        "weakness": "",
        "impact": "deadlock",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.8.0-rc6",
        "component": "ice driver"
    }
}
