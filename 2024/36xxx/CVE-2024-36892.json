{
  "cveId": "CVE-2024-36892",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved mm/slub avoid zeroing outside-object freepointer for single free Commit 284f17ac13fe (mm/slub handle bulk and single object freeing separately) splits single and bulk object freeing in two functions slab_free() and slab_free_bulk() which leads slab_free() to call slab_free_hook() directly instead of slab_free_freelist_hook(). If `init_on_free` is set, slab_free_hook() zeroes the object. Afterward, if `slub_debug=F` and `CONFIG_SLAB_FREELIST_HARDENED` are set, the do_slab_free() slowpath executes freelist consistency checks and try to decode a zeroed freepointer which leads to a Freepointer corrupt detection in check_object(). During bulk free, slab_free_freelist_hook() isnt affected as it always sets it objects freepointer using set_freepointer() to maintain its reconstructed freelist after `init_on_free`. For single free, objects freepointer thus needs to be avoided when stored outside the object if `init_on_free` is set. The freepointer left as is, check_object() may later detect an invalid pointer value due to objects overflow. To reproduce, set `slub_debug=FU init_on_free=1 log_level=7` on the command line of a kernel build with `CONFIG_SLAB_FREELIST_HARDENED=y`. dmesg sample log [ 10.708715] ============================================================================= [ 10.710323] BUG kmalloc-rnd-05-32 (Tainted G B T ) Freepointer corrupt [ 10.712695] ----------------",
  "keyphrases": {
    "rootcause": "zeroing outside-object freepointer for single free",
    "weakness": "overflow",
    "impact": "Freepointer corrupt detection",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "mm/slub"
  },
  "mitreTechnicalImpacts": []
}