{
  "cveId": "CVE-2024-49953",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved net/mlx5e Fix crash caused by calling __xfrm_state_delete() twice The km.state is not checked in drivers delayed work. When xfrm_state_check_expire() is called, the state can be reset to XFRM_STATE_EXPIRED, even if it is XFRM_STATE_DEAD already. This happens when xfrm state is deleted, but not freed yet. As __xfrm_state_delete() is called again in xfrm timer, the following crash occurs. To fix this issue, skip xfrm_state_check_expire() if km.state is not XFRM_STATE_VALID. Oops general protection fault, probably for non-canonical address 0xdead000000000108 0000 [#1] SMP CPU 5 UID 0 PID 7448 Comm kworker/u1022 Not tainted 6.11.0-rc2+ #1 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Workqueue mlx5e_ipsec eth%d mlx5e_ipsec_handle_sw_limits [mlx5_core] RIP 0010__xfrm_state_delete+0x3d/0x1b0 Code 0f 84 8b 01 00 00 48 89 fd c6 87 c8 00 00 00 05 48 8d bb 40 10 00 00 e8 11 04 1a 00 48 8b 95 b8 00 00 00 48 8b 85 c0 00 00 00 89 42 08 48 89 10 48 8b 55 10 48 b8 00 01 00 00 00 00 ad de 48 RSP 0018ffff88885f945ec8 EFLAGS 00010246 RAX dead000000000122 RBX ffffffff82afa940 RCX 0000000000000036 RDX dead000000000100 RSI 0000000000000000 RDI ffffffff82afb980 RBP ffff888109a20340 R08 ffff88885f945ea0 R09 0000000000000000 R10 0000000000000000 R11 ffff88885f945ff8 R12 0000000000000246 R13 ffff888109a20340 R14 ffff",
  "keyphrases": {
    "rootcause": "The km.state is not checked",
    "weakness": "",
    "impact": [
      "Oops",
      "crash",
      "general protection fault"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "net/mlx5e"
  },
  "mitreTechnicalImpacts": []
}