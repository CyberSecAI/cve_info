{
  "cveId": "CVE-2024-49949",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved net avoid potential underflow in qdisc_pkt_len_init() with UFO After commit 7c6d2ecbda83 (net be more gentle about silly gso requests coming from user) virtio_net_hdr_to_skb() had sanity check to detect malicious attempts from user space to cook a bad GSO packet. Then commit cf9acc90c80ec (net virtio_net_hdr_to_skb count transport header in UFO) while fixing one issue, allowed user space to cook a GSO packet with the following characteristic IPv4 SKB_GSO_UDP, gso_size=3, skb->len = 28. When this packet arrives in qdisc_pkt_len_init(), we end up with hdr_len = 28 (IPv4 header + UDP header), matching skb->len Then the following sets gso_segs to 0 gso_segs = DIV_ROUND_UP(skb->len - hdr_len, shinfo->gso_size) Then later we set qdisc_skb_cb(skb)->pkt_len to back to zero / qdisc_skb_cb(skb)->pkt_len += (gso_segs - 1) * hdr_len This leads to the following crash in fq_codel [1] qdisc_pkt_len_init() is best effort, we only want an estimation of the bytes sent on the wire, not crashing the kernel. This patch is fixing this particular issue, a following one adds more sanity checks for another potential bug. [1] [ 70.724101] BUG kernel NULL pointer dereference, address 0000000000000000 [ 70.724561] #PF supervisor read access in kernel mode [ 70.724561] #PF error_code(0x0000) - not-present page [ 70.724561] PGD 10ac61067 P4D 10ac61067 PUD 107ee2067 PMD 0 [",
  "keyphrases": {
    "rootcause": "",
    "weakness": "underflow",
    "impact": [
      "NULL pointer dereference",
      "read access"
    ],
    "vector": "bad GSO packet",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "qdisc_pkt_len_init() in virtio_net_hdr_to_skb"
  },
  "mitreTechnicalImpacts": []
}