{
  "cveId": "CVE-2024-39502",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved ionic fix use after netif_napi_del() When queues are started, netif_napi_add() and napi_enable() are called. If there are 4 queues and only 3 queues are used for the current configuration, only 3 queues napi should be registered and enabled. The ionic_qcq_enable() checks whether the .poll pointer is not NULL for enabling only the using queue napi. Unused queues napi will not be registered by netif_napi_add(), so the .poll pointer indicates NULL. But it couldnt distinguish whether the napi was unregistered or not because netif_napi_del() doesnt reset the .poll pointer to NULL. So, ionic_qcq_enable() calls napi_enable() for the queue, which was unregistered by netif_napi_del(). Reproducer ethtool -L rx 1 tx 1 combined 0 ethtool -L rx 0 tx 0 combined 1 ethtool -L rx 0 tx 0 combined 4 Splat looks like kernel BUG at net/core/dev.c6666! Oops invalid opcode 0000 [#1] PREEMPT SMP NOPTI CPU 3 PID 1057 Comm kworker/33 Not tainted 6.10.0-rc2+ #16 Workqueue events ionic_lif_deferred_work [ionic] RIP 0010napi_enable+0x3b/0x40 Code 48 89 c2 48 83 e2 f6 80 b9 61 09 00 00 00 74 0d 48 83 bf 60 01 00 00 00 74 03 80 ce 01 f0 4f RSP 0018ffffb6ed83227d48 EFLAGS 00010246 RAX 0000000000000000 RBX ffff97560cda0828 RCX 0000000000000029 RDX 0000000000000001 RSI 0000000000000000 RDI ffff97560cda0a28 RBP ffffb6ed83227d50 R08 0000000000000400 R0",
  "keyphrases": {
    "rootcause": "use after netif_napi_del()",
    "weakness": "",
    "impact": [
      "Oops invalid opcode",
      "kernel BUG"
    ],
    "vector": "ethtool -L ...",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "ionic_qcq_enable()"
  },
  "mitreTechnicalImpacts": []
}