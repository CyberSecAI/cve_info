{
    "cveId": "CVE-2024-39277",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved dma-mapping benchmark handle NUMA_NO_NODE correctly cpumask_of_node() can be called for NUMA_NO_NODE inside do_map_benchmark() resulting in the following sanitizer report UBSAN array-index-out-of-bounds in ./arch/x86/include/asm/topology.h7228 index -1 is out of range for type cpumask [64][1] CPU 1 PID 990 Comm dma_map_benchma Not tainted 6.9.0-rc6 #29 Hardware name QEMU Standard PC (i440FX + PIIX, 1996) Call Trace dump_stack_lvl (lib/dump_stack.c117) ubsan_epilogue (lib/ubsan.c232) __ubsan_handle_out_of_bounds (lib/ubsan.c429) cpumask_of_node (arch/x86/include/asm/topology.h72) [inline] do_map_benchmark (kernel/dma/map_benchmark.c104) map_benchmark_ioctl (kernel/dma/map_benchmark.c246) full_proxy_unlocked_ioctl (fs/debugfs/file.c333) __x64_sys_ioctl (fs/ioctl.c890) do_syscall_64 (arch/x86/entry/common.c83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S130) Use cpumask_of_node() in place when binding a kernel thread to a cpuset of a particular node. Note that the provided node id is checked inside map_benchmark_ioctl(). Its just a NUMA_NO_NODE case which is not handled properly later. Found by Linux Verification Center (linuxtesting.org).",
    "keyphrases": {
        "rootcause": "can be called for NUMA_NO_NODE inside do_map_benchmark()",
        "weakness": "array-index-out-of-bounds",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.9.0-rc6",
        "component": ""
    }
}
