{
    "cveId": "CVE-2024-39500",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvedsock_map avoid race between sock_map_close and sk_psock_putsk_psock_get will return NULL if the refcount of psock has gone to 0, whichwill happen when the last call of sk_psock_put is done. However,sk_psock_drop may not have finished yet, so the close callback will stillpoint to sock_map_close despite psock being NULL.This can be reproduced with a thread deleting an element from the sock map,while the second one creates a socket, adds it to the map and closes it.That will trigger the WARN_ON_ONCE------------[ cut here ]------------WARNING CPU 1 PID 7220 at net/core/sock_map.c1701 sock_map_close+0x2a2/0x2d0 net/core/sock_map.c1701Modules linked inCPU 1 PID 7220 Comm syz-executor380 Not tainted 6.9.0-syzkaller-07726-g3c999d1ae3c7 #0Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 04/02/2024RIP 0010sock_map_close+0x2a2/0x2d0 net/core/sock_map.c1701Code df e8 92 29 88 f8 48 8b 1b 48 89 d8 48 c1 e8 03 42 80 3c 20 00 74 08 48 89 df e8 79 29 88 f8 4c 8b 23 eb 89 e8 4f 15 23 f8 90 0b 90 48 83 c4 08 5b 41 5c 41 5d 41 5e 41 5f 5d e9 13 26 3d 02RSP 0018ffffc9000441fda8 EFLAGS 00010293RAX ffffffff89731ae1 RBX ffffffff94b87540 RCX ffff888029470000RDX 0000000000000000 RSI ffffffff8bcab5c0 RDI ffffffff8c1faba0RBP 0000000000000000 R08 ffffffff92f9b61f R09 1ffffffff25f36c3R10 dffffc0000000000 R11 fffffbfff25f36c4 R12 ffffffff89731840R13 ffff88804b587000 R14 ffff88804b587000 R15 ffffffff89731870FS 000055555e080380(0000) GSffff8880b9500000(0000) knlGS0000000000000000CS 0010 DS 0000 ES 0000 CR0 0000000080050033CR2 0000000000000000 CR3 00000000207d4000 CR4 0000000000350ef0Call Trace unix_release+0x87/0xc0 net/unix/af_unix.c1048 __sock_release net/socket.c659 [inline] sock_close+0xbe/0x240 net/socket.c1421 __fput+0x42b/0x8a0 fs/file_table.c422 __do_sys_close fs/open.c1556 [inline] __se_sys_close fs/open.c1541 [inline] __x64_sys_close+0x7f/0x110 fs/open.c1541 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xf5/0x240 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7fRIP 00330x7fb37d618070Code 00 00 48 c7 c2 b8 ff ff ff f7 d8 64 89 02 b8 ff ff ff ff eb d4 e8 10 2c 00 00 80 3d 31 f0 07 00 00 74 17 b8 03 00 00 00 0f 05 3d 00 f0 ff ff 77 48 c3 0f 1f 80 00 00 00 00 48 83 ec 18 89 7cRSP 002b00007ffcd4a525d8 EFLAGS 00000202 ORIG_RAX 0000000000000003RAX ffffffffffffffda RBX 0000000000000005 RCX 00007fb37d618070RDX 0000000000000010 RSI 00000000200001c0 RDI 0000000000000004RBP 0000000000000000 R08 0000000100000000 R09 0000000100000000R10 0000000000000000 R11 0000000000000202 R12 0000000000000000R13 0000000000000000 R14 0000000000000000 R15 0000000000000000 Use sk_psock, which will only check that the pointer is not been set toNULL yet, which should only happen after the callbacks are restored. If,then, a reference can still be gotten, we may call sk_psock_stop and cancelpsock->work.As suggested by Paolo Abeni, reorder the condition so the control flow isless convoluted.After that change, the reproducer does not trigger the WARN_ON_ONCEanymore.",
    "keyphrases": {
        "rootcause": "Race condition between sock_map_close and sk_psock_put leading to use-after-free",
        "weakness": "Incorrect reference counting and lack of synchronization in sock_map leading to a dangling pointer",
        "impact": "Kernel crash due to use-after-free, resulting in denial of service",
        "vector": "Local",
        "attacker": "Local user",
        "product": "Linux Kernel",
        "version": "6.9.0-syzkaller-07726-g3c999d1ae3c7",
        "component": "net/core/sock_map.c"
    }
}
