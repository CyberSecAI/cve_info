{
    "cveId": "CVE-2024-39500",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved sock_map avoid race between sock_map_close and sk_psock_put sk_psock_get will return NULL if the refcount of psock has gone to 0, which will happen when the last call of sk_psock_put is done. However, sk_psock_drop may not have finished yet, so the close callback will still point to sock_map_close despite psock being NULL. This can be reproduced with a thread deleting an element from the sock map, while the second one creates a socket, adds it to the map and closes it. That will trigger the WARN_ON_ONCE ------------[ cut here ]------------ WARNING CPU 1 PID 7220 at net/core/sock_map.c1701 sock_map_close+0x2a2/0x2d0 net/core/sock_map.c1701 Modules linked in CPU 1 PID 7220 Comm syz-executor380 Not tainted 6.9.0-syzkaller-07726-g3c999d1ae3c7 #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 04/02/2024 RIP 0010sock_map_close+0x2a2/0x2d0 net/core/sock_map.c1701 Code df e8 92 29 88 f8 48 8b 1b 48 89 d8 48 c1 e8 03 42 80 3c 20 00 74 08 48 89 df e8 79 29 88 f8 4c 8b 23 eb 89 e8 4f 15 23 f8 90 0b 90 48 83 c4 08 5b 41 5c 41 5d 41 5e 41 5f 5d e9 13 26 3d 02 RSP 0018ffffc9000441fda8 EFLAGS 00010293 RAX ffffffff89731ae1 RBX ffffffff94b87540 RCX ffff888029470000 RDX 0000000000000000 RSI ffffffff8bcab5c0 RDI ffffffff8c1faba0 RBP 0000000000000000 R08 ffffffff92f9b61f R09 1ffffffff25f36c3 R10 dffffc0000000000 R11 fffffbfff25f36c4 R12 ffffffff89731840 R13"
}
