{
    "cveId": "CVE-2024-39508",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved io_uring/io-wq Use set_bit() and test_bit() at worker->flags Utilize set_bit() and test_bit() on worker->flags within io_uring/io-wq to address potential data races. The structure io_worker->flags may be accessed through various data paths, leading to concurrency issues. When KCSAN is enabled, it reveals data races occurring in io_worker_handle_work and io_wq_activate_free_worker functions. BUG KCSAN data-race in io_worker_handle_work / io_wq_activate_free_worker write to 0xffff8885c4246404 of 4 bytes by task 49071 on cpu 28 io_worker_handle_work (io_uring/io-wq.c434 io_uring/io-wq.c569) io_wq_worker (io_uring/io-wq.c?) read to 0xffff8885c4246404 of 4 bytes by task 49024 on cpu 5 io_wq_activate_free_worker (io_uring/io-wq.c? io_uring/io-wq.c285) io_wq_enqueue (io_uring/io-wq.c947) io_queue_iowq (io_uring/io_uring.c524) io_req_task_submit (io_uring/io_uring.c1511) io_handle_tw_list (io_uring/io_uring.c1198) Line numbers against commit 18daea77cca6 (Merge tag for-linus of git//git.kernel.org/pub/scm/virt/kvm/kvm). These races involve writes and reads to the same memory location by different tasks running on different CPUs. To mitigate this, refactor the code to use atomic operations such as set_bit(), test_bit(), and clear_bit() instead of basic and and or operations. This ensures thread-safe manipulation of worker flags. Also, move `create_index` to avoid",
    "keyphrases": {
        "rootcause": "data races",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "io_uring/io-wq"
    }
}
