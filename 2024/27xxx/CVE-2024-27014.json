{
    "cveId": "CVE-2024-27014",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net/mlx5e Prevent deadlock while disabling aRFS When disabling aRFS under the `priv->state_lock`, any scheduled aRFS works are canceled using the `cancel_work_sync` function, which waits for the work to end if it has already started. However, while waiting for the work handler, the handler will try to acquire the `state_lock` which is already acquired. The worker acquires the lock to delete the rules if the state is down, which is not the workers responsibility since disabling aRFS deletes the rules. Add an aRFS state variable, which indicates whether the aRFS is enabled and prevent adding rules when the aRFS is disabled. Kernel log ====================================================== WARNING possible circular locking dependency detected 6.7.0-rc4_net_next_mlx5_5483eb2 #1 Tainted G I ------------------------------------------------------ ethtool/386089 is trying to acquire lock ffff88810f21ce68 ((work_completion)(&rule->arfs_work)){+.+.}-{00}, at __flush_work+0x74/0x4e0 but task is already holding lock ffff8884a1808cc0 (&priv->state_lock){+.+.}-{33}, at mlx5e_ethtool_set_channels+0x53/0x200 [mlx5_core] which lock already depends on the new lock. the existing dependency chain (in reverse order) is -> #1 (&priv->state_lock){+.+.}-{33} __mutex_lock+0x80/0xc90 arfs_handle_work+0x4b/0x3b0 [mlx5_core] process_one_work+0x1dc/0x4a0 worker_thread+0x1bf/0x3",
    "keyphrases": {
        "rootcause": "",
        "weakness": "circular locking dependency",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "6.7.0-rc4_net_next_mlx5_5483eb2 #1 Tainted G",
        "component": "net/mlx5e"
    }
}
