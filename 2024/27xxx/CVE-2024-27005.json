{
    "cveId": "CVE-2024-27005",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved interconnect Dont access req_list while its being manipulated The icc_lock mutex was split into separate icc_lock and icc_bw_lock mutexes in [1] to avoid lockdep splats. However, this didnt adequately protect access to icc_nodereq_list. The icc_set_bw() function will eventually iterate over req_list while only holding icc_bw_lock, but req_list can be modified while only holding icc_lock. This causes races between icc_set_bw(), of_icc_get(), and icc_put(). Example A CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&icc_bw_lock) icc_put(path_b) mutex_lock(&icc_lock) aggregate_requests() hlist_for_each_entry(r, ... hlist_del(... Example B CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&icc_bw_lock) path_b = of_icc_get() of_icc_get_by_index() mutex_lock(&icc_lock) path_find() path_init() aggregate_requests() hlist_for_each_entry(r, ... hlist_add_head",
    "keyphrases": {
        "rootcause": "races between icc_set_bw(), of_icc_get(), and icc_put()",
        "weakness": "improper mutex locking",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": ""
    }
}
