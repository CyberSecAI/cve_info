{
    "cveId": "CVE-2024-27012",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved netfilter nf_tables restore set elements when delete set fails From abort path, nft_mapelem_activate() needs to restore refcounters to the original state. Currently, it uses the set->ops->walk() to iterate over these set elements. The existing set iterator skips inactive elements in the next generation, this does not work from the abort path to restore the original state since it has to skip active elements instead (not inactive ones). This patch moves the check for inactive elements to the set iterator callback, then it reverses the logic for the .activate case which needs to skip active elements. Toggle next generation bit for elements when delete set command is invoked and call nft_clear() from .activate (abort) path to restore the next generation bit. The splat below shows an object in mappings memleak [43929.457523] ------------[ cut here ]------------ [43929.457532] WARNING CPU 0 PID 1139 at include/net/netfilter/nf_tables.h1237 nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables] [...] [43929.458014] RIP 0010nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables] [43929.458076] Code 83 f8 01 77 ab 49 8d 7c 24 08 e8 37 5e d0 de 49 8b 6c 24 08 48 8d 7d 50 e8 e9 5c d0 de 8b 45 50 8d 50 ff 89 55 50 85 c0 75 86 0b eb 82 0f 0b eb b3 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90 [43929.458081] RSP 0018ffff888140f9f4b0 EFLAGS 00010246 [43929.458086] RAX 0000000000000000 RBX ffff8881434f5288 RCX d",
    "keyphrases": {
        "rootcause": "",
        "weakness": "memory leak",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "netfilter nf_tables"
    }
}
