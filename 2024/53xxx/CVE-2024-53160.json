{
    "cveId": "CVE-2024-53160",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved rcu/kvfree Fix data-race in __mod_timer / kvfree_call_rcu KCSAN reports a data race when access the krcp->monitor_work.timer.expires variable in the schedule_delayed_monitor_work() function BUG KCSAN data-race in __mod_timer / kvfree_call_rcu read to 0xffff888237d1cce8 of 8 bytes by task 10149 on cpu 1 schedule_delayed_monitor_work kernel/rcu/tree.c3520 [inline] kvfree_call_rcu+0x3b8/0x510 kernel/rcu/tree.c3839 trie_update_elem+0x47c/0x620 kernel/bpf/lpm_trie.c441 bpf_map_update_value+0x324/0x350 kernel/bpf/syscall.c203 generic_map_update_batch+0x401/0x520 kernel/bpf/syscall.c1849 bpf_map_do_batch+0x28c/0x3f0 kernel/bpf/syscall.c5143 __sys_bpf+0x2e5/0x7a0 __do_sys_bpf kernel/bpf/syscall.c5741 [inline] __se_sys_bpf kernel/bpf/syscall.c5739 [inline] __x64_sys_bpf+0x43/0x50 kernel/bpf/syscall.c5739 x64_sys_call+0x2625/0x2d60 arch/x86/include/generated/asm/syscalls_64.h322 do_syscall_x64 arch/x86/entry/common.c52 [inline] do_syscall_64+0xc9/0x1c0 arch/x86/entry/common.c83 entry_SYSCALL_64_after_hwframe+0x77/0x7f write to 0xffff888237d1cce8 of 8 bytes by task 56 on cpu 0 __mod_timer+0x578/0x7f0 kernel/time/timer.c1173 add_timer_global+0x51/0x70 kernel/time/timer.c1330 __queue_delayed_work+0x127/0x1a0 kernel/workqueue.c2523 queue_delayed_work_on+0xdf/0x190 kernel/workqueue.c2552 queue_delayed_work include/linux/workqueue.h677 [inline] schedule_delayed_monitor_work kernel/rcu/tree.c3525 [inline] kfree_rcu_monitor+0x5e8/0x660 kernel/rcu/tree.c3643 process_one_work kernel/workqueue.c3229 [inline] process_scheduled_works+0x483/0x9a0 kernel/workqueue.c3310 worker_thread+0x51d/0x6f0 kernel/workqueue.c3391 kthread+0x1d1/0x210 kernel/kthread.c389 ret_from_fork+0x4b/0x60 arch/x86/kernel/process.c147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S244 Reported by Kernel Concurrency Sanitizer on CPU 0 UID 0 PID 56 Comm kworker/u84 Not tainted 6.12.0-rc2-syzkaller-00050-g5b7c893ed5ed #0 Hardware name Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue events_unbound kfree_rcu_monitor kfree_rcu_monitor() rearms the work if a krcp has to be still offloaded and this is done without holding krcp->lock, whereas the kvfree_call_rcu() holds it. Fix it by acquiring the krcp->lock for kfree_rcu_monitor() so both functions do not race anymore.",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "rcu/kvfree"
    }
}
