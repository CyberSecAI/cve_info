{
    "cveId": "CVE-2024-41053",
    "version": "1.0.0",
    "timestamp": "2024-12-19T22:22:49.126128+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolvedscsi ufs core Fix ufshcd_abort_one racing issueWhen ufshcd_abort_one is racing with the completion ISR, the completed tagof the requests mq_hctx pointer will be set to NULL by ISR. Returnsuccess when request is completed by ISR because ufshcd_abort_one does notneed to do anything.The racing flow isThread Aufshcd_err_handler step 1 ... ufshcd_abort_one ufshcd_try_to_abort_task ufshcd_cmd_inflight(true) step 3 ufshcd_mcq_req_to_hwq blk_mq_unique_tag rq->mq_hctx->queue_num step 5Thread Bufs_mtk_mcq_intr(cq complete ISR) step 2 scsi_done ... __blk_mq_free_request rq->mq_hctx = NULL step 4Below is KE back trace. ufshcd_try_to_abort_task cmd at tag 41 not pending in the device. ufshcd_try_to_abort_task cmd at tag=41 is cleared. Aborting tag 41 / CDB 0x28 succeeded Unable to handle kernel NULL pointer dereference at virtual address 0000000000000194 pc [0xffffffddd7a79bf8] blk_mq_unique_tag+0x8/0x14 lr [0xffffffddd6155b84] ufshcd_mcq_req_to_hwq+0x1c/0x40 [ufs_mediatek_mod_ise] do_mem_abort+0x58/0x118 el1_abort+0x3c/0x5c el1h_64_sync_handler+0x54/0x90 el1h_64_sync+0x68/0x6c blk_mq_unique_tag+0x8/0x14 ufshcd_err_handler+0xae4/0xfa8 [ufs_mediatek_mod_ise] process_one_work+0x208/0x4fc worker_thread+0x228/0x438 kthread+0x104/0x1d4 ret_from_fork+0x10/0x20",
    "keyphrases": {
        "rootcause": "A race condition exists between the ufshcd_abort_one function and the completion interrupt service routine (ISR). The ISR can set the mq_hctx pointer of a completed request to NULL before ufshcd_abort_one accesses it, leading to a NULL pointer dereference.",
        "weakness": "The ufshcd_abort_one function does not properly handle the case where a request is completed by the ISR concurrently. Specifically, it attempts to access the mq_hctx pointer after it may have been nulled out by the ISR.",
        "impact": "Kernel crash due to a NULL pointer dereference. This can lead to denial of service.",
        "vector": "Concurrency vulnerability triggered by a race condition",
        "attacker": "",
        "product": "Linux Kernel",
        "version": "",
        "component": "scsi ufs core"
    }
}