{
  "cveId": "CVE-2024-41066",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved ibmvnic Add tx check to prevent skb leak Below is a summary of how the driver stores a reference to an skb during transmit tx_buff[free_map[consumer_index]]->skb = new_skb free_map[consumer_index] = IBMVNIC_INVALID_MAP consumer_index ++ Where variable data looks like this free_map == [4, IBMVNIC_INVALID_MAP, IBMVNIC_INVALID_MAP, 0, 3] consumer_index^ tx_buff == [skb=null, skb=, skb=, skb=null, skb=null] The driver has checks to ensure that free_map[consumer_index] pointed to a valid index but there was no check to ensure that this index pointed to an unused/null skb address. So, if, by some chance, our free_map and tx_buff lists become out of sync then we were previously risking an skb memory leak. This could then cause tcp congestion control to stop sending packets, eventually leading to ETIMEDOUT. Therefore, add a conditional to ensure that the skb address is null. If not then warn the user (because this is still a bug that should be patched) and free the old pointer to prevent memleak/tcp problems.",
  "keyphrases": {
    "rootcause": "improper memory management",
    "weakness": "memory leak",
    "impact": "skb memory leak",
    "vector": "out-of-sync free_map and tx_buff lists",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "ibmvnic driver"
  },
  "mitreTechnicalImpacts": []
}