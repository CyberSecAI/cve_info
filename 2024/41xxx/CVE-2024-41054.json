{
    "cveId": "CVE-2024-41054",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved scsi ufs core Fix ufshcd_clear_cmd racing issue When ufshcd_clear_cmd is racing with the completion ISR, the completed tag of the requests mq_hctx pointer will be set to NULL by the ISR. And ufshcd_clear_cmds call to ufshcd_mcq_req_to_hwq will get NULL pointer KE. Return success when the request is completed by ISR because sq does not need cleanup. The racing flow is Thread A ufshcd_err_handlerstep 1 ufshcd_try_to_abort_task ufshcd_cmd_inflight(true)step 3 ufshcd_clear_cmd ... ufshcd_mcq_req_to_hwq blk_mq_unique_tag rq->mq_hctx->queue_numstep 5 Thread B ufs_mtk_mcq_intr(cq complete ISR)step 2 scsi_done ... __blk_mq_free_request rq->mq_hctx = NULLstep 4 Below is KE back trace ufshcd_try_to_abort_task cmd pending in the device. tag = 6 Unable to handle kernel NULL pointer dereference at virtual address 0000000000000194 pc [0xffffffd589679bf8] blk_mq_unique_tag+0x8/0x14 lr [0xffffffd5862f95b4] ufshcd_mcq_sq_cleanup+0x6c/0x1cc [ufs_mediatek_mod_ise] Workqueue ufs_eh_wq_0 ufshcd_err_handler [ufs_mediatek_mod_ise] Call trace dump_backtrace+0xf8/0x148 show_stack+0x18/0x24 dump_stack_lvl+0x60/0x7c dump_stack+0x18/0x3c mrdump_common_die+0x24c/0x398 [mrdump] ipanic_die+0x20/0x34 [mrdump] notify_die+0x80/0xd8 die+0x94/0x2b8 __do_kernel_fault+0x264/0x298 do_page_fault+0xa4/0x4b8 do_translation_fault+0x38/0x54 do_mem_abort+0x58/0x118"
}
