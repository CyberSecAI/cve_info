{
  "cveId": "CVE-2024-35870",
  "version": "1.0.0",
  "timestamp": "2024-12-06T11:32:07.789868+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved smb client fix UAF in smb2_reconnect_server() The UAF bug is due to smb2_reconnect_server() accessing a session that is already being teared down by another thread that is executing __cifs_put_smb_ses(). This can happen when (a) the client has connection to the server but no session or (b) another thread ends up setting @ses->ses_status again to something different than SES_EXITING. To fix this, we need to make sure to unconditionally set @ses->ses_status to SES_EXITING and prevent any other threads from setting a new status while were still tearing it down. The following can be reproduced by adding some delay to right after the ipc is freed in __cifs_put_smb_ses() - which will give smb2_reconnect_server() worker a chance to run and then accessing @ses->ipc kinit ... mount.cifs //srv/share /mnt/1 -o sec=krb5,nohandlecache,echo_interval=10 [disconnect srv] ls /mnt/1 &>/dev/null sleep 30 kdestroy [reconnect srv] sleep 10 umount /mnt/1 ... CIFS VFS Verify user has a krb5 ticket and keyutils is installed CIFS VFS \\\\srv Send error in SessSetup = -126 CIFS VFS Verify user has a krb5 ticket and keyutils is installed CIFS VFS \\\\srv Send error in SessSetup = -126 general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b 0000 [#1] PREEMPT SMP NOPTI CPU 3 PID 50 Comm kworker/31 Not tainted 6.9.0-rc2 #1 Hardware name QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39 04/",
  "keyphrases": {
    "rootcause": "UAF bug in smb2_reconnect_server()",
    "weakness": "",
    "impact": "general protection fault",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "6.9.0-rc2",
    "component": ""
  },
  "mitreTechnicalImpacts": []
}