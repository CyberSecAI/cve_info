{
    "cveId": "CVE-2024-35797",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mm cachestat fix two shmem bugs When cachestat on shmem races with swapping and invalidation, there are two possible bugs 1) A swapin error can have resulted in a poisoned swap entry in the shmem inodes xarray. Calling get_shadow_from_swap_cache() on it will result in an out-of-bounds access to swapper_spaces[]. Validate the entry with non_swap_entry() before going further. 2) When we find a valid swap entry in the shmems inode, the shadow entry in the swapcache might not exist yet swap IO is still in progress and were before __remove_mapping swapin, invalidation, or swapoff have removed the shadow from swapcache after we saw the shmem swap entry. This will send a NULL to workingset_test_recent(). The latter purely operates on pointer bits, so it wont crash - node 0, memcg ID 0, eviction timestamp 0, etc. are all valid inputs - but its a bogus test. In theory that could result in a false recently evicted count. Such a false positive wouldnt be the end of the world. But for code clarity and (future) robustness, be explicit about this case. Bail on get_shadow_from_swap_cache() returning NULL.",
    "keyphrases": {
        "rootcause": "race condition",
        "weakness": "",
        "impact": "out-of-bounds access",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "mm cachestat"
    }
}
