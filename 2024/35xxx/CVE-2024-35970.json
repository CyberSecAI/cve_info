{
    "cveId": "CVE-2024-35970",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved af_unix Clear stale u->oob_skb. syzkaller started to report deadlock of unix_gc_lock after commit 4090fa373f0e (af_unix Replace garbage collection algorithm.), but it just uncovers the bug that has been there since commit 314001f0bf92 (af_unix Add OOB support). The repro basically does the following. from socket import * from array import array c1, c2 = socketpair(AF_UNIX, SOCK_STREAM) c1.sendmsg([ba], [(SOL_SOCKET, SCM_RIGHTS, array(i, [c2.fileno()]))], MSG_OOB) c2.recv(1) # blocked as no normal data in recv queue c2.close() # done async and unblock recv() c1.close() # done async and trigger GC A socket sends its file descriptor to itself as OOB data and tries to receive normal data, but finally recv() fails due to async close(). The problem here is wrong handling of OOB skb in manage_oob(). When recvmsg() is called without MSG_OOB, manage_oob() is called to check if the peeked skb is OOB skb. In such a case, manage_oob() pops it out of the receive queue but does not clear unix_sock(sk)->oob_skb. This is wrong in terms of uAPI. Lets say we send hello with MSG_OOB, and world without MSG_OOB. The o is handled as OOB data. When recv() is called twice without MSG_OOB, the OOB data should be lost. >>> from socket import * >>> c1, c2 = socketpair(AF_UNIX, SOCK_STREAM, 0) >>> c1.send(bhello, MSG_OOB) # o is OOB data 5 >>> c1.send(bworld) 5 >>> c2.",
    "keyphrases": {
        "rootcause": "wrong handling of OOB skb in manage_oob()",
        "weakness": "",
        "impact": "deadlock",
        "vector": "sending its file descriptor to itself as OOB data",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "af_unix"
    }
}
