{
    "cveId": "CVE-2024-35873",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved riscv Fix vector state restore in rt_sigreturn() The RISC-V Vector specification states in Appendix D Calling Convention for Vector State [1] that Executing a system call causes all caller-saved vector registers (v0-v31, vl, vtype) and vstart to become unspecified.. In the RISC-V kernel this is called discarding the vstate. Returning from a signal handler via the rt_sigreturn() syscall, vector discard is also performed. However, this is not an issue since the vector state should be restored from the sigcontext, and therefore not care about the vector discard. The live state is the actual vector register in the running context, and the vstate is the vector state of the task. A dirty live state, means that the vstate and live state are not in synch. When vectorized user_from_copy() was introduced, an bug sneaked in at the restoration code, related to the discard of the live state. An example when this go wrong 1. A userland application is executing vector code 2. The application receives a signal, and the signal handler is entered. 3. The application returns from the signal handler, using the rt_sigreturn() syscall. 4. The live vector state is discarded upon entering the rt_sigreturn(), and the live state is marked as dirty, indicating that the live state need to be synchronized with the current vstate. 5. rt_sigreturn() restores the vstate, except the Ve",
    "keyphrases": {
        "rootcause": "improper vector state discard",
        "weakness": "",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "rt_sigreturn()"
    }
}
