{
    "cveId": "CVE-2024-35977",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved platform/chrome cros_ec_uart properly fix race condition The cros_ec_uart_probe() function calls devm_serdev_device_open() before it calls serdev_device_set_client_ops(). This can trigger a NULL pointer dereference BUG kernel NULL pointer dereference, address 0000000000000000 ... Call Trace ... ? ttyport_receive_buf A simplified version of crashing code is as follows static inline size_t serdev_controller_receive_buf(struct serdev_controller *ctrl, const u8 *data, size_t count) { struct serdev_device *serdev = ctrl->serdev if (!serdev || !serdev->ops->receive_buf) // CRASH! return 0 return serdev->ops->receive_buf(serdev, data, count) } It assumes that if SERPORT_ACTIVE is set and serdev exists, serdev->ops will also exist. This conflicts with the existing cros_ec_uart_probe() logic, as it first calls devm_serdev_device_open() (which sets SERPORT_ACTIVE), and only later sets serdev->ops via serdev_device_set_client_ops(). Commit 01f95d42b8f4 (platform/chrome cros_ec_uart fix race condition) attempted to fix a similar race condition, but while doing so, made the window of error for this race condition to happen much wider. Attempt to fix the race condition again, making sure we fully",
    "keyphrases": {
        "rootcause": "improper order of function calls",
        "weakness": "NULL pointer dereference",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "cros_ec_uart"
    }
}
