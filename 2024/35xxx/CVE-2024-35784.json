{
    "cveId": "CVE-2024-35784",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved btrfs fix deadlock with fiemap and extent locking While working on the patchset to remove extent locking I got a lockdep splat with fiemap and pagefaulting with my new extent lock replacement lock. This deadlock exists with our normal code, we just dont have lockdep annotations with the extent locking so weve never noticed it. Since were copying the fiemap extent to user space on every iteration we have the chance of pagefaulting. Because we hold the extent lock for the entire range we could mkwrite into a range in the file that we have mmaped. This would deadlock with the following stack trace [] lock_extent+0x28d/0x2f0 [] btrfs_page_mkwrite+0x273/0x8a0 [] do_page_mkwrite+0x50/0xb0 [] do_fault+0xc1/0x7b0 [] __handle_mm_fault+0x2fa/0x460 [] handle_mm_fault+0xa4/0x330 [] do_user_addr_fault+0x1f4/0x800 [] exc_page_fault+0x7c/0x1e0 [] asm_exc_page_fault+0x26/0x30 [] rep_movs_alternative+0x33/0x70 [] _copy_to_user+0x49/0x70 [] fiemap_fill_next_extent+0xc8/0x120 [] emit_fiemap_extent+0x4d/0xa0 [] extent_fiemap+0x7f8/0xad0 [] btrfs_fiemap+0x49/0x80 [] __x64_sys_ioctl+0x3e1/0xb50 [] do_syscall_64+0x94/0x1a0 [] entry_SYSCALL_64_after_hwframe+0x6e/0x76 I wrote an fstest to reproduce this deadlock without my replacement lock and verified that the deadlock exists with our existing locking. To fix this simply dont take the extent lock for the entire dur",
    "keyphrases": {
        "rootcause": "",
        "weakness": "deadlock",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "btrfs"
    }
}
