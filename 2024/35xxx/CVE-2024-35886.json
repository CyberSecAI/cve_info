{
    "cveId": "CVE-2024-35886",
    "version": "1.0.0",
    "timestamp": "2024-12-06T11:32:07.789868+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved ipv6 Fix infinite recursion in fib6_dump_done(). syzkaller reported infinite recursive calls of fib6_dump_done() during netlink socket destruction. [1] From the log, syzkaller sent an AF_UNSPEC RTM_GETROUTE message, and then the response was generated. The following recvmmsg() resumed the dump for IPv6, but the first call of inet6_dump_fib() failed at kzalloc() due to the fault injection. [0] 120134 executing program 3 r0 = socket$nl_route(0x10, 0x3, 0x0) sendmsg$nl_route(r0, ... snip ...) recvmmsg(r0, ... snip ...) (fail_nth 8) Here, fib6_dump_done() was set to nlk_sk(sk)->cb.done, and the next call of inet6_dump_fib() set it to nlk_sk(sk)->cb.args[3]. syzkaller stopped receiving the response halfway through, and finally netlink_sock_destruct() called nlk_sk(sk)->cb.done(). fib6_dump_done() calls fib6_dump_end() and nlk_sk(sk)->cb.done() if it is still not NULL. fib6_dump_end() rewrites nlk_sk(sk)->cb.done() by nlk_sk(sk)->cb.args[3], but it has the same function, not NULL, calling itself recursively and hitting the stack guard page. To avoid the issue, lets set the destructor after kzalloc(). [0] FAULT_INJECTION forcing a failure. name failslab, interval 1, probability 0, space 0, times 0 CPU 1 PID 432110 Comm syz-executor.3 Not tainted 6.8.0-12821-g537c2e91d354-dirty #11 Hardware name QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org",
    "keyphrases": {
        "rootcause": "infinite recursion",
        "weakness": "",
        "impact": "",
        "vector": "AF_UNSPEC RTM_GETROUTE message",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "fib6_dump_done()"
    }
}
