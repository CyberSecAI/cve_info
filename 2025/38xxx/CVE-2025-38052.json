{
    "cveId": "CVE-2025-38052",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved net/tipc fix slab-use-after-free Read in tipc_aead_encrypt_done Syzbot reported a slab-use-after-free with the following call trace ================================================================== BUG KASAN slab-use-after-free in tipc_aead_encrypt_done+0x4bd/0x510 net/tipc/crypto.c840 Read of size 8 at addr ffff88807a733000 by task kworker/10/25 Call Trace kasan_report+0xd9/0x110 mm/kasan/report.c601 tipc_aead_encrypt_done+0x4bd/0x510 net/tipc/crypto.c840 crypto_request_complete include/crypto/algapi.h266 aead_request_complete include/crypto/internal/aead.h85 cryptd_aead_crypt+0x3b8/0x750 crypto/cryptd.c772 crypto_request_complete include/crypto/algapi.h266 cryptd_queue_worker+0x131/0x200 crypto/cryptd.c181 process_one_work+0x9fb/0x1b60 kernel/workqueue.c3231 Allocated by task 8355 kzalloc_noprof include/linux/slab.h778 tipc_crypto_start+0xcc/0x9e0 net/tipc/crypto.c1466 tipc_init_net+0x2dd/0x430 net/tipc/core.c72 ops_init+0xb9/0x650 net/core/net_namespace.c139 setup_net+0x435/0xb40 net/core/net_namespace.c343 copy_net_ns+0x2f0/0x670 net/core/net_namespace.c508 create_new_namespaces+0x3ea/0xb10 kernel/nsproxy.c110 unshare_nsproxy_namespaces+0xc0/0x1f0 kernel/nsproxy.c228 ksys_unshare+0x419/0x970 kernel/fork.c3323 __do_sys_unshare kernel/fork.c3394 Freed by task 63 kfree+0x12a/0x3b0 mm/slub.c4557 tipc_crypto_stop+0x23c/0x500 net/tipc/crypto.c1539 tipc_exit_net+0x8c/0x110 net/tipc/core.c119 ops_exit_list+0xb0/0x180 net/core/net_namespace.c173 cleanup_net+0x5b7/0xbf0 net/core/net_namespace.c640 process_one_work+0x9fb/0x1b60 kernel/workqueue.c3231 After freed the tipc_crypto tx by delete namespace, tipc_aead_encrypt_done may still visit it in cryptd_queue_worker workqueue. I reproduce this issue by ip netns add ns1 ip link add veth1 type veth peer name veth2 ip link set veth1 netns ns1 ip netns exec ns1 tipc bearer enable media eth dev veth1 ip netns exec ns1 tipc node set key this_is_a_master_key master ip netns exec ns1 tipc bearer disable media eth dev veth1 ip netns del ns1 The key of reproduction is that, simd_aead_encrypt is interrupted, leading to crypto_simd_usable() return false. Thus, the cryptd_queue_worker is triggered, and the tipc_crypto tx will be visited. tipc_disc_timeout tipc_bearer_xmit_skb tipc_crypto_xmit tipc_aead_encrypt crypto_aead_encrypt // encrypt() simd_aead_encrypt // crypto_simd_usable() is false child = &ctx->cryptd_tfm->base simd_aead_encrypt crypto_aead_encrypt // encrypt() cryptd_aead_encrypt_enqueue cryptd_aead_enqueue cryptd_enqueue_request // trigger cryptd_queue_worker queue_work_on(smp_processor_id(), cryptd_wq, &cpu_queue->work) Fix this by holding net reference count before encrypt.",
    "keyphrases": {
        "component": "net/tipc",
        "rootcause": "slab-use-after-free, use of freed memory",
        "vector": "",
        "weakness": "",
        "product": "Linux kernel",
        "impact": "",
        "attacker": "",
        "version": ""
    }
}
