{
  "cveId": "CVE-2025-38151",
  "version": "1.0.0",
  "timestamp": "2025-07-05T08:16:57.403025+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved RDMA/cma Fix hang when cma_netevent_callback fails to queue_work The cited commit fixed a crash when cma_netevent_callback was called for a cma_id while work on that id from a previous call had not yet started. The work item was re-initialized in the second call, which corrupted the work item currently in the work queue. However, it left a problem when queue_work fails (because the item is still pending in the work queue from a previous call). In this case, cma_id_put (which is called in the work handler) is therefore not called. This results in a userspace process hang (zombie process). Fix this by calling cma_id_put() if queue_work fails.",
  "keyphrases": {
    "rootcause": "",
    "weakness": "",
    "impact": "hang",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "RDMA/cma"
  },
  "mitreTechnicalImpacts": []
}