{
    "cveId": "CVE-2025-38027",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved regulator max20086 fix invalid memory access max20086_parse_regulators_dt() calls of_regulator_match() using an array of struct of_regulator_match allocated on the stack for the matches argument. of_regulator_match() calls devm_of_regulator_put_matches(), which calls devres_alloc() to allocate a struct devm_of_regulator_matches which will be de-allocated using devm_of_regulator_put_matches(). struct devm_of_regulator_matches is populated with the stack allocated matches array. If the device fails to probe, devm_of_regulator_put_matches() will be called and will try to call of_node_put() on that stack pointer, generating the following dmesg entries max20086 6-0028 Failed to read DEVICE_ID reg -121 kobject \\\\xc0$\\\\xa5\\\\x03 (000000002cebcb7a) is not initialized, yet kobject_put() is being called. Followed by a stack trace matching the call flow described above. Switch to allocating the matches array using devm_kcalloc() to avoid accessing the stack pointer long after its out of scope. This also has the advantage of allowing multiple max20086 to probe without overriding the data stored inside the global of_regulator_match.",
    "keyphrases": {
        "rootcause": "stack pointer is out of scope",
        "weakness": "invalid memory access",
        "impact": "kobject_put() is being called",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "max20086_parse_regulators_dt()"
    }
}
