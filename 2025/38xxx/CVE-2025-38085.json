{
  "cveId": "CVE-2025-38085",
  "version": "1.0.0",
  "timestamp": "2025-07-05T08:16:57.403025+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved mm/hugetlb fix huge_pmd_unshare() vs GUP-fast race huge_pmd_unshare() drops a reference on a page table that may have previously been shared across processes, potentially turning it into a normal page table used in another process in which unrelated VMAs can afterwards be installed. If this happens in the middle of a concurrent gup_fast(), gup_fast() could end up walking the page tables of another process. While I dont see any way in which that immediately leads to kernel memory corruption, it is really weird and unexpected. Fix it with an explicit broadcast IPI through tlb_remove_table_sync_one(), just like we do in khugepaged when removing page tables for a THP collapse.",
  "keyphrases": {
    "rootcause": "",
    "weakness": [
      "memory corruption",
      "race condition"
    ],
    "impact": "kernel memory corruption",
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "mm/hugetlb fix huge_pmd_unshare() vs GUP-fast"
  },
  "mitreTechnicalImpacts": []
}