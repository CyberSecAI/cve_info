{
    "cveId": "CVE-2025-38084",
    "version": "1.0.0",
    "timestamp": "2025-07-05T08:16:57.403025+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved mm/hugetlb unshare page tables during VMA split, not before Currently, __split_vma() triggers hugetlb page table unsharing through vm_ops->may_split(). This happens before the VMA lock and rmap locks are taken - which is too early, it allows racing VMA-locked page faults in our process and racing rmap walks from other processes to cause page tables to be shared again before we actually perform the split. Fix it by explicitly calling into the hugetlb unshare logic from __split_vma() in the same place where THP splitting also happens. At that point, both the VMA and the rmap(s) are write-locked. An annoying detail is that we can now call into the helper hugetlb_unshare_pmds() from two different locking contexts 1. from hugetlb_split(), holding - mmap lock (exclusively) - VMA lock - file rmap lock (exclusively) 2. hugetlb_unshare_all_pmds(), which I think is designed to be able to call us with only the mmap lock held (in shared mode), but currently only runs while holding mmap lock (exclusively) and VMA lock Backporting note This commit fixes a racy protection that was introduced in commit b30c14cd6102 (hugetlb unshare some PMDs when splitting VMAs) that commit claimed to fix an issue introduced in 5.13, but it should actually also go all the way back. [jannh@google.com v2]",
    "keyphrases": {
        "rootcause": "racing VMA-locked page faults and racing rmap walks",
        "weakness": "racy protection",
        "impact": "share page tables again",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "mm/hugetlb"
    }
}
