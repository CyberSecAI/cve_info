{
    "cveId": "CVE-2025-22059",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved udp Fix multiple wraparounds of sk->sk_rmem_alloc. __udp_enqueue_schedule_skb() has the following condition if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf) goto drop sk->sk_rcvbuf is initialised by net.core.rmem_default and later can be configured by SO_RCVBUF, which is limited by net.core.rmem_max, or SO_RCVBUFFORCE. If we set INT_MAX to sk->sk_rcvbuf, the condition is always false as sk->sk_rmem_alloc is also signed int. Then, the size of the incoming skb is added to sk->sk_rmem_alloc unconditionally. This results in integer overflow (possibly multiple times) on sk->sk_rmem_alloc and allows a single socket to have skb up to net.core.udp_mem[1]. For example, if we set a large value to udp_mem[1] and INT_MAX to sk->sk_rcvbuf and flood packets to the socket, we can see multiple overflows # cat /proc/net/sockstat | grep UDP UDP inuse 3 mem 7956736 INT_MAX * 15 ^- PAGE_SHIFT # ss -uam State Recv-Q ... UNCONN -1757018048 ... sk_rmem_alloc). A complete fix would be to revert it and cap the right operand by INT_MAX rmem = atomic_add_return(size, &sk->sk_rmem_alloc) if (rmem > min(size + (unsigned int)sk->sk_rcvbuf, INT_MAX)) goto uncharge_drop but we do not want to add the expensive atomic_add_return() back just for the corner case. Casting rmem to unsigned int prevents multiple wraparounds, but we still allow a single wraparound. # cat /proc/net/sockstat | grep UDP UDP inuse 3 mem 524288 > 12 # ss -uam State Recv-Q ... UNCONN -2147482816 ... truesize only when rcvbuf is large enough to lower the overflow possibility. Note that we still have a small chance to see overflow if multiple skbs to the same socket are processed on different core at the same time and each size does not exceed the limit but the total size does. Note also that we must ignore skb->truesize for a small buffer as explained in commit 363dc73acacb (udp be less conservative with sock rmem accounting).",
    "keyphrases": {
        "rootcause": "",
        "weakness": "integer overflow",
        "impact": "have skb up to net.core.udp_mem[1]",
        "vector": "INT_MAX to sk->sk_rcvbuf",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "__udp_enqueue_schedule_skb()"
    }
}
