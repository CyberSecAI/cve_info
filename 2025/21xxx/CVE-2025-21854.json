{
    "cveId": "CVE-2025-21854",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved sockmap, vsock For connectible sockets allow only connected sockmap expects all vsocks to have a transport assigned, which is expressed in vsock_protopsock_update_sk_prot(). However, there is an edge case where an unconnected (connectible) socket may lose its previously assigned transport. This is handled with a NULL check in the vsock/BPF recv path. Another design detail is that listening vsocks are not supposed to have any transport assigned at all. Which implies they are not supported by the sockmap. But this is complicated by the fact that a socket, before switching to TCP_LISTEN, may have had some transport assigned during a failed connect() attempt. Hence, we may end up with a listening vsock in a sockmap, which blows up quickly KASAN null-ptr-deref in range [0x0000000000000120-0x0000000000000127] CPU 7 UID 0 PID 56 Comm kworker/70 Not tainted 6.14.0-rc1+ Workqueue vsock-loopback vsock_loopback_work RIP 0010vsock_read_skb+0x4b/0x90 Call Trace sk_psock_verdict_data_ready+0xa4/0x2e0 virtio_transport_recv_pkt+0x1ca8/0x2acc vsock_loopback_work+0x27d/0x3f0 process_one_work+0x846/0x1420 worker_thread+0x5b3/0xf80 kthread+0x35a/0x700 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x1a/0x30 For connectible sockets, instead of relying solely on the state of vsk->transport, tell sockmap to only allow those representing established connections. This aligns with the behaviour for AF_INET and AF_UNIX.",
    "keyphrases": {
        "rootcause": "NULL check in the vsock/BPF recv path",
        "weakness": "null-ptr-deref",
        "impact": "blow up quickly KASAN null-ptr-deref",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "vsock/BPF recv path"
    }
}
