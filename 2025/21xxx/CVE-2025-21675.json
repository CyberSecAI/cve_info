{
  "cveId": "CVE-2025-21675",
  "version": "1.0.0",
  "timestamp": "2025-07-04T16:12:41.853043+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved net/mlx5 Clear port select structure when fail to create Clear the port select structure on error so no stale values left after definers are destroyed. Thats because the mlx5_lag_destroy_definers() always try to destroy all lag definers in the tt_map, so in the flow below lag definers get double-destroyed and cause kernel crash mlx5_lag_port_sel_create() mlx5_lag_create_definers() mlx5_lag_create_definer() <- Failed on tt 1 mlx5_lag_destroy_definers() <- definers[tt=0] gets destroyed mlx5_lag_port_sel_create() mlx5_lag_create_definers() mlx5_lag_create_definer() <- Failed on tt 0 mlx5_lag_destroy_definers() <- definers[tt=0] gets double-destroyed Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008 Mem abort info ESR = 0x0000000096000005 EC = 0x25 DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x05 level 1 translation fault Data abort info ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 user pgtable 64k pages, 48-bit VAs, pgdp=0000000112ce2e00 [0000000000000008] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000 Internal error Oops 0000000096000005",
  "keyphrases": {
    "rootcause": "kernel NULL pointer dereference",
    "weakness": "",
    "impact": [
      "kernel crash",
      "Oops"
    ],
    "vector": "double-destroyed",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "mlx5"
  },
  "mitreTechnicalImpacts": []
}