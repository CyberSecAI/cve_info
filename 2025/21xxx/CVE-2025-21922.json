{
    "cveId": "CVE-2025-21922",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved ppp Fix KMSAN uninit-value warning with bpf Syzbot caught an KMSAN uninit-value warning [1], which is caused by the ppp driver not initializing a 2-byte header when using socket filter. The following code can generate a PPP filter BPF program struct bpf_program fp pcap_t *handle handle = pcap_open_dead(DLT_PPP_PPPD, 65535) pcap_compile(handle, &fp, ip and outbound, 0, 0) bpf_dump(&fp, 1) Its output is (000) ldh [2] (001) jeq #0x21 jt 2 jf 5 (002) ldb [0] (003) jeq #0x1 jt 4 jf 5 (004) ret #65535 (005) ret #0 Wen can find similar code at the following link https//github.com/ppp-project/ppp/blob/master/pppd/options.c#L1680 The maintainer of this code repository is also the original maintainer of the ppp driver. As you can see the BPF program skips 2 bytes of data and then reads the Protocol field to determine if its an IP packet. Then it read the first byte of the first 2 bytes to determine the direction. The issue is that only the first byte indicating direction is initialized in current ppp driver code while the second byte is not initialized. For normal BPF programs generated by libpcap, uninitialized data wont be used, so its not a problem. However, for carefully crafted BPF programs, such as those generated by syzkaller [2], which start reading from offset 0, the uninitialized data will be used and caught by KMSAN. [1] https//syzkaller.appspot.com/bug?extid=853242d9c9917165d791 [2] https//syzkaller.appspot.com/text?tag=ReproC&x=11994913980000",
    "keyphrases": {
        "rootcause": "ppp driver not initializing a 2-byte header when using socket filter",
        "weakness": "uninitialized value",
        "impact": "",
        "vector": "",
        "attacker": "",
        "product": "Linux kernel",
        "version": "",
        "component": "ppp driver"
    }
}
