{
    "cveId": "CVE-2025-21810",
    "version": "1.0.0",
    "timestamp": "2025-07-04T16:12:41.853043+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved driver core class Fix wild pointer dereferences in API class_dev_iter_next() There are a potential wild pointer dereferences issue regarding APIs class_dev_iter_(init|next|exit)(), as explained by below typical usage // All members of @iter are wild pointers. struct class_dev_iter iter // class_dev_iter_init(@iter, @class, ...) checks parameter @class for // potential class_to_subsys() error, and it returns void type and does // not initialize its output parameter @iter, so caller can not detect // the error and continues to invoke class_dev_iter_next(@iter) even if // @iter still contains wild pointers. class_dev_iter_init(&iter, ...) // Dereference these wild pointers in @iter here once suffer the error. while (dev = class_dev_iter_next(&iter)) { ... } // Also dereference these wild pointers here. class_dev_iter_exit(&iter) Actually, all callers of these APIs have such usage pattern in kernel tree. Fix by - Initialize output parameter @iter by memset() in class_dev_iter_init() and give callers prompt by pr_crit() for the error. - Check if @iter is valid in class_dev_iter_next().",
    "keyphrases": {
        "component": "driver core, APIs class_dev_iter_(init|next|exit)()",
        "rootcause": "wild pointer dereferences, uninitialized output parameter",
        "vector": "",
        "weakness": "",
        "product": "Linux kernel",
        "impact": "",
        "attacker": "",
        "version": ""
    }
}
