{
  "cveId": "CVE-2025-21970",
  "version": "1.0.0",
  "timestamp": "2025-07-04T16:12:41.853043+00:00",
  "description": "In the Linux kernel, the following vulnerability has been resolved net/mlx5 Bridge, fix the crash caused by LAG state check When removing LAG device from bridge, NETDEV_CHANGEUPPER event is triggered. Driver finds the lower devices (PFs) to flush all the offloaded entries. And mlx5_lag_is_shared_fdb is checked, it returns false if one of PF is unloaded. In such case, mlx5_esw_bridge_lag_rep_get() and its caller return NULL, instead of the alive PF, and the flush is skipped. Besides, the bridge fdb entrys lastuse is updated in mlx5 bridge event handler. But this SWITCHDEV_FDB_ADD_TO_BRIDGE event can be ignored in this case because the upper interface for bond is deleted, and the entry will never be aged because lastuse is never updated. To make things worse, as the entry is alive, mlx5 bridge workqueue keeps sending that event, which is then handled by kernel bridge notifier. It causes the following crash when accessing the passed bond netdev which is already destroyed. To fix this issue, remove such checks. LAG state is already checked in commit 15f8f168952f (net/mlx5 Bridge, verify LAG state when adding bond to bridge), driver still need to skip offload if LAG becomes invalid state after initialization. Oops stack segment 0000",
  "keyphrases": {
    "rootcause": "",
    "weakness": "",
    "impact": [
      "crash",
      "Oops"
    ],
    "vector": "",
    "attacker": "",
    "product": "Linux kernel",
    "version": "",
    "component": "net/mlx5 Bridge"
  },
  "mitreTechnicalImpacts": []
}